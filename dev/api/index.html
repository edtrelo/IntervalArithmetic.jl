<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · IntervalArithmetic</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">IntervalArithmetic</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Package</a></li><li><a class="tocitem" href="../intro/">Interval Arithmetic</a></li><li><a class="tocitem" href="../construction/">Constructing intervals</a></li><li><a class="tocitem" href="../usage/">Basic usage</a></li><li><a class="tocitem" href="../decorations/">Decorations</a></li><li><a class="tocitem" href="../multidim/">Multi-dimensional boxes</a></li><li><a class="tocitem" href="../rounding/">Rounding</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../input_output/">Input&amp;Output</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#IntervalArithmetic.DECORATION"><code>IntervalArithmetic.DECORATION</code></a></li><li><a href="#IntervalArithmetic.DecoratedInterval"><code>IntervalArithmetic.DecoratedInterval</code></a></li><li><a href="#IntervalArithmetic.Flavor"><code>IntervalArithmetic.Flavor</code></a></li><li><a href="#IntervalArithmetic.Interval"><code>IntervalArithmetic.Interval</code></a></li><li><a href="#IntervalArithmetic.IntervalBox"><code>IntervalArithmetic.IntervalBox</code></a></li><li><a href="#IntervalArithmetic.IntervalRounding"><code>IntervalArithmetic.IntervalRounding</code></a></li><li><a href="#IntervalArithmetic.Region"><code>IntervalArithmetic.Region</code></a></li><li><a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>IntervalArithmetic.@I_str</code></a></li><li><a href="#IntervalArithmetic.@round-Tuple{Any, Any, Any}"><code>IntervalArithmetic.@round</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:*</code></a></li><li><a href="#Base.:+-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:+</code></a></li><li><a href="#Base.:--Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:-</code></a></li><li><a href="#Base.:--Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:-</code></a></li><li><a href="#Base.:/-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:/</code></a></li><li><a href="#Base.:^-Union{Tuple{F}, Tuple{F, F}} where F&lt;:Interval"><code>Base.:^</code></a></li><li><a href="#Base.Math.acot-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.acot</code></a></li><li><a href="#Base.Math.acoth-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.acoth</code></a></li><li><a href="#Base.Math.cot-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.cot</code></a></li><li><a href="#Base.Math.coth-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.coth</code></a></li><li><a href="#Base.Math.csc-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.csc</code></a></li><li><a href="#Base.Math.csch-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.csch</code></a></li><li><a href="#Base.Math.hypot-Tuple{Interval, Interval}"><code>Base.Math.hypot</code></a></li><li><a href="#Base.Math.sec-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.sec</code></a></li><li><a href="#Base.Math.sech-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.sech</code></a></li><li><a href="#Base.abs-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.abs</code></a></li><li><a href="#Base.acos-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.acos</code></a></li><li><a href="#Base.acosh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.acosh</code></a></li><li><a href="#Base.asin-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.asin</code></a></li><li><a href="#Base.asinh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.asinh</code></a></li><li><a href="#Base.atan-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.atan</code></a></li><li><a href="#Base.atanh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.atanh</code></a></li><li><a href="#Base.ceil-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.ceil</code></a></li><li><a href="#Base.cos-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.cos</code></a></li><li><a href="#Base.cosh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.cosh</code></a></li><li><a href="#Base.floor-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.floor</code></a></li><li><a href="#Base.fma-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.fma</code></a></li><li><a href="#Base.hash-Tuple{Interval, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.in-Tuple{Real, Interval}"><code>Base.in</code></a></li><li><a href="#Base.intersect-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>Base.intersect</code></a></li><li><a href="#Base.intersect"><code>Base.intersect</code></a></li><li><a href="#Base.intersect-Tuple{Union{Complex{&lt;:Interval}, Interval}, Vararg{Union{Complex{&lt;:Interval}, Interval}}}"><code>Base.intersect</code></a></li><li><a href="#Base.inv-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.inv</code></a></li><li><a href="#Base.isdisjoint-Tuple{Interval, Interval}"><code>Base.isdisjoint</code></a></li><li><a href="#Base.issubset-Tuple{Interval, Interval}"><code>Base.issubset</code></a></li><li><a href="#Base.max-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.max</code></a></li><li><a href="#Base.min-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.min</code></a></li><li><a href="#Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}}, AbstractString}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.parse</code></a></li><li><a href="#Base.parse-Union{Tuple{F}, Tuple{Type{F}, AbstractString}} where F&lt;:Interval"><code>Base.parse</code></a></li><li><a href="#Base.round-Tuple{Interval}"><code>Base.round</code></a></li><li><a href="#Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, IntervalBox{N, T}}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>Base.setdiff</code></a></li><li><a href="#Base.setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.setdiff</code></a></li><li><a href="#Base.sign-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sign</code></a></li><li><a href="#Base.signbit-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.signbit</code></a></li><li><a href="#Base.sin-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sin</code></a></li><li><a href="#Base.sinh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sinh</code></a></li><li><a href="#Base.sqrt-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sqrt</code></a></li><li><a href="#Base.tan-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.tan</code></a></li><li><a href="#Base.tanh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.tanh</code></a></li><li><a href="#Base.trunc-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.trunc</code></a></li><li><a href="#Base.union"><code>Base.union</code></a></li><li><a href="#Base.union-Tuple{Union{Complex{&lt;:Interval}, Interval}, Union{Complex{&lt;:Interval}, Interval}}"><code>Base.union</code></a></li><li><a href="#Base.zero-Union{Tuple{Type{IntervalBox{N, T}}}, Tuple{T}, Tuple{N}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>Base.zero</code></a></li><li><a href="#IntervalArithmetic.:±-Tuple{Any, Any}"><code>IntervalArithmetic.:±</code></a></li><li><a href="#IntervalArithmetic.:≛-Tuple{Interval, Interval}"><code>IntervalArithmetic.:≛</code></a></li><li><a href="#IntervalArithmetic.:≛-Tuple{Interval, Real}"><code>IntervalArithmetic.:≛</code></a></li><li><a href="#IntervalArithmetic.:⊂-Tuple{Interval, Interval}"><code>IntervalArithmetic.:⊂</code></a></li><li><a href="#IntervalArithmetic._parse-Union{Tuple{T}, Tuple{Type{Interval{T}}, AbstractString}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic._parse</code></a></li><li><a href="#IntervalArithmetic._setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic._setdiff</code></a></li><li><a href="#IntervalArithmetic.atomic-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.atomic</code></a></li><li><a href="#IntervalArithmetic.bigequiv-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.bigequiv</code></a></li><li><a href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a></li><li><a href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a></li><li><a href="#IntervalArithmetic.bisect-Union{Tuple{Interval{T}}, Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.bisect</code></a></li><li><a href="#IntervalArithmetic.bounds-Tuple{Interval}"><code>IntervalArithmetic.bounds</code></a></li><li><a href="#IntervalArithmetic.cancelminus"><code>IntervalArithmetic.cancelminus</code></a></li><li><a href="#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.cancelminus</code></a></li><li><a href="#IntervalArithmetic.cancelplus-Tuple{Interval, Interval}"><code>IntervalArithmetic.cancelplus</code></a></li><li><a href="#IntervalArithmetic.cancelplus"><code>IntervalArithmetic.cancelplus</code></a></li><li><a href="#IntervalArithmetic.default_numtype-Tuple{}"><code>IntervalArithmetic.default_numtype</code></a></li><li><a href="#IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.diam</code></a></li><li><a href="#IntervalArithmetic.div_by_thin_zero-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.div_by_thin_zero</code></a></li><li><a href="#IntervalArithmetic.emptyinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.emptyinterval</code></a></li><li><a href="#IntervalArithmetic.entireinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.entireinterval</code></a></li><li><a href="#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.extended_div</code></a></li><li><a href="#IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.find_quadrants</code></a></li><li><a href="#IntervalArithmetic.hull"><code>IntervalArithmetic.hull</code></a></li><li><a href="#IntervalArithmetic.hull-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.hull</code></a></li><li><a href="#IntervalArithmetic.inf-Tuple{Interval}"><code>IntervalArithmetic.inf</code></a></li><li><a href="#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.interval</code></a></li><li><a href="#IntervalArithmetic.is_valid_interval-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.is_valid_interval</code></a></li><li><a href="#IntervalArithmetic.isatomic-Tuple{Interval}"><code>IntervalArithmetic.isatomic</code></a></li><li><a href="#IntervalArithmetic.iscommon-Tuple{Interval}"><code>IntervalArithmetic.iscommon</code></a></li><li><a href="#IntervalArithmetic.isinterior-Tuple{Interval, Interval}"><code>IntervalArithmetic.isinterior</code></a></li><li><a href="#IntervalArithmetic.isstrictless-Tuple{Interval, Interval}"><code>IntervalArithmetic.isstrictless</code></a></li><li><a href="#IntervalArithmetic.isthin-Tuple{Interval}"><code>IntervalArithmetic.isthin</code></a></li><li><a href="#IntervalArithmetic.isthininteger-Tuple{Interval}"><code>IntervalArithmetic.isthininteger</code></a></li><li><a href="#IntervalArithmetic.isthinzero-Tuple{Interval}"><code>IntervalArithmetic.isthinzero</code></a></li><li><a href="#IntervalArithmetic.isweaklyless-Tuple{Interval, Interval}"><code>IntervalArithmetic.isweaklyless</code></a></li><li><a href="#IntervalArithmetic.mag-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mag</code></a></li><li><a href="#IntervalArithmetic.mid-Tuple{IntervalBox}"><code>IntervalArithmetic.mid</code></a></li><li><a href="#IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mid</code></a></li><li><a href="#IntervalArithmetic.midpoint_radius-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.midpoint_radius</code></a></li><li><a href="#IntervalArithmetic.mig-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mig</code></a></li><li><a href="#IntervalArithmetic.mince-Union{Tuple{N}, Tuple{IntervalBox{N}, Int64}} where N"><code>IntervalArithmetic.mince</code></a></li><li><a href="#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Any}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.mince</code></a></li><li><a href="#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mince</code></a></li><li><a href="#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Tuple{Vararg{Int64, N}}}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.mince</code></a></li><li><a href="#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.nai</code></a></li><li><a href="#IntervalArithmetic.nthroot-Tuple{Interval{BigFloat}, Integer}"><code>IntervalArithmetic.nthroot</code></a></li><li><a href="#IntervalArithmetic.numtype-Tuple{F} where F"><code>IntervalArithmetic.numtype</code></a></li><li><a href="#IntervalArithmetic.overlap-Tuple{Interval, Interval}"><code>IntervalArithmetic.overlap</code></a></li><li><a href="#IntervalArithmetic.parse_num-Union{Tuple{T}, Tuple{S}, Tuple{Type{T}, AbstractString, RoundingMode{:Down}}} where {S&lt;:Integer, T&lt;:Rational{S}}"><code>IntervalArithmetic.parse_num</code></a></li><li><a href="#IntervalArithmetic.pow-Union{Tuple{T}, Tuple{Interval{T}, Integer}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.pow</code></a></li><li><a href="#IntervalArithmetic.precedes-Tuple{Interval, Interval}"><code>IntervalArithmetic.precedes</code></a></li><li><a href="#IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.promote_numtype</code></a></li><li><a href="#IntervalArithmetic.radius-Tuple{Interval}"><code>IntervalArithmetic.radius</code></a></li><li><a href="#IntervalArithmetic.round_expr-Tuple{Expr, RoundingMode}"><code>IntervalArithmetic.round_expr</code></a></li><li><a href="#IntervalArithmetic.scaled_mid-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.scaled_mid</code></a></li><li><a href="#IntervalArithmetic.setformat"><code>IntervalArithmetic.setformat</code></a></li><li><a href="#IntervalArithmetic.strictprecedes-Tuple{Interval, Interval}"><code>IntervalArithmetic.strictprecedes</code></a></li><li><a href="#IntervalArithmetic.sup-Tuple{Interval}"><code>IntervalArithmetic.sup</code></a></li><li><a href="#IntervalArithmetic.symmetric_box-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.symmetric_box</code></a></li><li><a href="#IntervalArithmetic.unsafe_scale-Union{Tuple{T}, Tuple{T, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.unsafe_scale</code></a></li><li><a href="#IntervalArithmetic.zero_times_infinity-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.zero_times_infinity</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.DECORATION" href="#IntervalArithmetic.DECORATION"><code>IntervalArithmetic.DECORATION</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DECORATION</code></pre><p>Enumeration constant for the types of interval decorations. The nomenclature follows Section 11.2 of the IEEE Standard 1788-2015:</p><ul><li><code>com -&gt; 4</code>: non-empty, continuous and bounded (common)</li><li><code>dac -&gt; 3</code>: non-empty and continuous (defined and continuous)</li><li><code>def -&gt; 2</code>: non-empty (defined)</li><li><code>trv -&gt; 1</code>: always true (trivial)</li><li><code>ill -&gt; 0</code>: not an interval (ill-formed)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/intervals.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.DecoratedInterval" href="#IntervalArithmetic.DecoratedInterval"><code>IntervalArithmetic.DecoratedInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecoratedInterval{T&lt;:NumTypes}</code></pre><p>Wraps an <code>Interval</code> together with a <code>DECORATION</code>, i.e. a flag that records the status of the interval when thought of as the result of a previously executed sequence of functions acting on an initial interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/intervals.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.Flavor" href="#IntervalArithmetic.Flavor"><code>IntervalArithmetic.Flavor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flavor{F}</code></pre><p>Super type of all interval flavors.</p><p>A flavor defines (following the IEEE Std 1788-2015) how an interval behaves in edge cases. This mostly makes a difference when dealing with infinity and division by zero.</p><p>Currently only Flavor{:set_based} is supported.</p><ul><li><code>:set_based</code> (default) : Elements of an interval are real number.   In particular, infinity is never part of an interval and is only used as a   shorthand.   For example, the interval <code>(2..Inf)</code> contain all real number greater than 2.   In particular, this means that <code>(Inf..Inf)</code> is an empty interval, and division   by a thin zero returns the empty interval.   The edge cases are       - <code>x/(0..0) ≛ ∅</code>       - <code>(0..0)/(0..0) ≛ ∅</code>       - <code>(0..0)*(-Inf..Inf) ≛ 0</code>       - <code>Inf ∈ (0..Inf) == false</code>   This flavor is described and required in part 2 of the IEEE Std 1799-2015.</li><li><code>:cset</code> (not implemented) : Elements of an interval are either real numbers   or <code>±Inf</code>, applying standard rule for arithmetic with infinity.   The edge cases are       - <code>x/(0..0) ≛ (-Inf..Inf)</code>       - <code>(0..0)/(0..0) ≛ (-Inf..Inf)</code>       - <code>(0..0)*(-Inf..Inf) ≛ (-Inf..Inf)</code>       - <code>Inf ∈ (0..Inf) == true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/flavors.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.Interval" href="#IntervalArithmetic.Interval"><code>IntervalArithmetic.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Interval{T&lt;:NumTypes} &lt;: Real</code></pre><p>Interval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015.</p><p>Fields:</p><ul><li><code>lo::T</code></li><li><code>hi::T</code></li></ul><p>Constructors compliant with the IEEE Standard 1788-2015:</p><ul><li><a href="#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>interval</code></a></li><li><a href="@ref"><code>..</code></a></li><li><a href="#IntervalArithmetic.:±-Tuple{Any, Any}"><code>±</code></a></li><li><a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>@I_str</code></a></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The internal constructor <code>unsafe_interval</code> is <em>not</em> compliant with the IEEE Standard 1788-2015.</p></div></div><p>See also: <a href="#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>interval</code></a>, <a href="#IntervalArithmetic.:±-Tuple{Any, Any}"><code>±</code></a>, <a href="@ref"><code>..</code></a> and <a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>@I_str</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.IntervalBox" href="#IntervalArithmetic.IntervalBox"><code>IntervalArithmetic.IntervalBox</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>IntervalBox</code> is an <code>N</code>-dimensional rectangular box, given by a Cartesian product of a vector of <code>N</code> <code>Interval</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/intervalbox.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.IntervalRounding" href="#IntervalArithmetic.IntervalRounding"><code>IntervalArithmetic.IntervalRounding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalRounding{T}</code></pre><p>Interval rounding trait type.</p><p>Allowed rounding types are</p><ul><li><code>:tight</code>: fast, tight (correct) rounding with errorfree arithmetic via           FastRounding.jl.</li><li><code>:accurate</code>: fast &quot;accurate&quot; rounding using prevfloat and nextfloat              (slightly wider than needed).</li><li><code>:slow</code>: tight (correct) rounding by changing rounding mode (slow).</li><li><code>:none</code>: no rounding (for speed comparisons; no enclosure is guaranteed).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/rounding.jl#L33-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.@I_str-Tuple{Any}" href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>IntervalArithmetic.@I_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">I&quot;str&quot;</code></pre><p>Create an interval according to the IEEE Standard 1788-2015. This is semantically equivalent to <code>parse(DecoratedInterval{default_numtype()}, str)</code> if the string contains the character <code>_</code> which delimits the interval and its decoration; otherwise, it is semantically equivalent to <code>parse(Interval{default_numtype()}, str)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; I&quot;[3, 4]&quot;
Interval{Float64}(3.0, 4.0)

julia&gt; I&quot;0.1&quot;
Interval{Float64}(0.09999999999999999, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/parsing.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.@round-Tuple{Any, Any, Any}" href="#IntervalArithmetic.@round-Tuple{Any, Any, Any}"><code>IntervalArithmetic.@round</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@round(F, ex1, ex2)</code></pre><p>Macro for internal use that creates an interval of flavor F by rounding down <code>ex1</code> and rounding up <code>ex2</code>. Each expression may consist of only a <em>single</em> operation that needs rounding, e.g. <code>a.lo + b.lo</code> or <code>sin(a.lo)</code>. It also handles <code>min(...)</code> and <code>max(...)</code>, where the arguments are each themselves single operations.</p><p>The macro uses the internal <code>round_expr</code> function to transform e.g. <code>a + b</code> into <code>+(a, b, RoundDown)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/rounding_macros.jl#L34-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.:*-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(a::Interval, b::Interval)
*(a::Interval, b::Real)
*(a::Real, b::Interval)</code></pre><p>Implement the <code>mul</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The behavior of the multiplication is flavor dependent for some edge cases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.:+-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(a::Interval, b::Interval)
+(a::Interval, b::Real)
+(a::Real, b::Interval)</code></pre><p>Implement the <code>add</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.:--Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(a::Interval)</code></pre><p>Implement the <code>neg</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.:--Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(a::Interval, b::Interval)
-(a::Interval, b::Real)
-(a::Real, b::Interval)</code></pre><p>Implement the <code>sub</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.:/-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">/(a::Interval, b::Interval)
/(a::Interval, b::Real)
/(a::Real, b::Interval)</code></pre><p>Implement the <code>div</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The behavior of the division is flavor dependent for some edge cases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L134-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Union{Tuple{F}, Tuple{F, F}} where F&lt;:Interval" href="#Base.:^-Union{Tuple{F}, Tuple{F, F}} where F&lt;:Interval"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(a::Interval, b::Interval)
^(a::Interval, b)</code></pre><p>Implement the <code>pow</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/power.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.acot-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.acot-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.acot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acot(a::Interval)</code></pre><p>Implement the <code>acot</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L535-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.acoth-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.acoth-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.acoth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acoth(a::Interval)</code></pre><p>Implement the <code>acoth</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.cot-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.cot-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.cot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cot(a::Interval)</code></pre><p>Implement the <code>cot</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.coth-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.coth-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.coth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coth(a::Interval)</code></pre><p>Implement the <code>coth</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.csc-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.csc-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.csc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">csc(a::Interval)</code></pre><p>Implement the <code>csc</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.csch-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.csch-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.csch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">csch(a::Interval)</code></pre><p>Implement the <code>csch</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.hypot-Tuple{Interval, Interval}" href="#Base.Math.hypot-Tuple{Interval, Interval}"><code>Base.Math.hypot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hypot(x::Interval, n::Integer)</code></pre><p>Direct implemntation of <code>hypot</code> using intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/power.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.sec-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.sec-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sec(a::Interval)</code></pre><p>Implement the <code>sec</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.sech-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.Math.sech-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.Math.sech</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sech(a::Interval)</code></pre><p>Implement the <code>sech</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.abs-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs(a::Interval)</code></pre><p>Implement the <code>abs</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/absmax.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.acos-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.acos-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.acos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acos(a::Interval)</code></pre><p>Implement the <code>acos</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L439-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.acosh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.acosh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.acosh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acosh(a::Interval)</code></pre><p>Implement the <code>acosh</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.asin-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.asin-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.asin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asin(a::Interval)</code></pre><p>Implement the <code>asin</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.asinh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.asinh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.asinh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asinh(a::Interval)</code></pre><p>Implement the <code>asinh</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.atan-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.atan-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.atan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atan(a::Interval)</code></pre><p>Implement the <code>atan</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L452-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.atanh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.atanh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.atanh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atanh(a::Interval)</code></pre><p>Implement the <code>atanh</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ceil-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.ceil-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.ceil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil(a::Interval)</code></pre><p>Implement the <code>ceil</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/integer.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cos-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.cos-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.cos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cos(a::Interval)</code></pre><p>Implement the <code>cos</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cosh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.cosh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.cosh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cosh(a::Interval)</code></pre><p>Implement the <code>cosh</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.floor-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor(a::Interval)</code></pre><p>Implement the <code>floor</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/integer.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fma-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.fma-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.fma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fma(a::Interval, b::Interval, c::Interval)</code></pre><p>Fused multiply-add.</p><p>Implement the <code>fma</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hash-Tuple{Interval, UInt64}" href="#Base.hash-Tuple{Interval, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hash(x::Interval, h)</code></pre><p>Compute the integer hash code for an interval using the method for composite types used in <code>AutoHashEquals.jl</code>.</p><p>Note that in <code>IntervalArithmetic.jl</code>, equality of intervals is given by <code>≛</code> rather than the <code>==</code> operator. The latter is reserved for the pointwise extension of equality to intervals and uses three-way logic by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/real_interface.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Real, Interval}" href="#Base.in-Tuple{Real, Interval}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(x, a)
∈(x, a)</code></pre><p>Checks if the number <code>x</code> is a member of the interval <code>a</code>, treated as a set.</p><p>Implement the <code>isMember</code> function of the IEEE Standard 1788-2015 (section 10.6.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L156-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intersect(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/functions.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect-Tuple{Union{Complex{&lt;:Interval}, Interval}, Vararg{Union{Complex{&lt;:Interval}, Interval}}}" href="#Base.intersect-Tuple{Union{Complex{&lt;:Interval}, Interval}, Vararg{Union{Complex{&lt;:Interval}, Interval}}}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(a::Interval{T}...) where T</code></pre><p>Return the n-ary intersection of its arguments.</p><p>This function is applicable to any number of input intervals, as in <code>intersect(a1, a2, a3, a4)</code> where <code>ai</code> is an interval. If your use case needs to splat the input, as in <code>intersect(a...)</code>, consider <code>reduce(intersect, a)</code> instead, because you save the cost of splatting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/set_operations.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}" href="#Base.intersect-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(a, b)
∩(a,b)</code></pre><p>Returns the intersection of the intervals <code>a</code> and <code>b</code>, considered as (extended) sets of real numbers. That is, the set that contains the points common in <code>a</code> and <code>b</code>.</p><p>Implement the <code>intersection</code> function of the IEEE Standard 1788-2015 (Section 9.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/set_operations.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.inv-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(a::Interval)</code></pre><p>Implement the <code>recip</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The behavior of the division is flavor dependent for some edge cases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L188-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isdisjoint-Tuple{Interval, Interval}" href="#Base.isdisjoint-Tuple{Interval, Interval}"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isdisjoint(a,b)</code></pre><p>Checks if all the points of the interval <code>a</code> are within the interior of interval <code>b</code>.</p><p>Implement the <code>disjoint</code> function of the IEEE Standard 1788-2015 (Table 9.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issubset-Tuple{Interval, Interval}" href="#Base.issubset-Tuple{Interval, Interval}"><code>Base.issubset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊆(a,b)</code></pre><p>Checks if all the points of the interval <code>a</code> are within the interval <code>b</code>.</p><p>Typed with \subseteq&lt;TAB&gt;.</p><p>Implement the <code>subset</code> function of the IEEE Standard 1788-2015 (Table 9.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.max-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.max-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max(a::Interval, b::Interval)</code></pre><p>Implement the <code>max</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/absmax.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.min-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.min-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min(a::Interval, b::Interval)</code></pre><p>Implement the <code>min</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/absmax.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Union{Tuple{F}, Tuple{Type{F}, AbstractString}} where F&lt;:Interval" href="#Base.parse-Union{Tuple{F}, Tuple{Type{F}, AbstractString}} where F&lt;:Interval"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(Interval, s::AbstractString)</code></pre><p>Create an interval according to the IEEE Standard 1788-2015. In contrast with constructors that do not use strings, this constructor guarantees that the returned interval tightly encloses the values described by the string, including numbers that have no exact float representation (e.g. 0.1).</p><p>Examples of allowed string formats:</p><ul><li><code>I&quot;[1.33]&quot;</code> or <code>I&quot;1.33&quot;</code>: the interval containing <span>$1.33$</span>.</li><li><code>I&quot;[1.44, 2.78]&quot;</code>: the interval <span>$[1.44, 2.78]$</span>.</li><li><code>I&quot;[empty]&quot;</code>: the empty interval.</li><li><code>I&quot;[entire]&quot;</code> or <code>I&quot;[,]&quot;</code>: the interval <span>$[-\infty, \infty]$</span>.</li><li><code>I&quot;[3,]&quot;</code>: the interval <span>$[3, \infty]$</span>.</li><li><code>I&quot;6.42?2&quot;</code>: the interval <span>$[6.4,  6.44]$</span>. The number after <code>?</code> represents the   uncertainty in the last digit; by default this value is <code>0.5</code>. The direction   of the uncertainty can be given by adding <code>u</code> or <code>d</code> at the end for the error   to only go up or down respectively (e.g. <code>I&quot;4.5?5u&quot;</code> represents <span>$[4.5, 5]$</span>).</li><li><code>I&quot;6.42?2e2&quot;</code>: the interval <span>$[642, 644]$</span>.</li><li><code>I&quot;3??u&quot;</code>: the interval <span>$[3, \infty]$</span>.</li><li><code>I&quot;3??u&quot;</code>: the interval <span>$[3, \infty]$</span>.</li><li><code>I&quot;3??&quot;</code>: the interval <span>$[-\infty, \infty]$</span>.</li></ul><p>For more details, see sections 9.7 and 12.11 of the IEEE Standard 1788-2015.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; parse(Interval{Float64}, &quot;[1, 2]&quot;)
Interval{Float64}(1.0, 2.0)

julia&gt; parse(Interval{Float64}, &quot;[1, 2]&quot;)
Interval{Float64}(1.0, 2.0)

julia&gt; parse(Interval{Float64}, &quot;[1,]&quot;)
Interval{Float64}(1.0, Inf)

julia&gt; parse(Interval{Float64}, &quot;[,]&quot;)
Interval{Float64}(-Inf, Inf)

julia&gt; parse(Interval{Float64}, &quot;6.42?2e2&quot;)
Interval{Float64}(640.0, 644.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/parsing.jl#L31-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}}, AbstractString}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}}, AbstractString}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(DecoratedInterval, s::AbstractString)</code></pre><p>Parse a string of the form <code>&quot;[a, b]_dec&quot;</code> as a <code>DecoratedInterval</code> with decoration <code>dec</code>. If the decoration is not specified, it is computed based on the parsed interval. If the input is an invalid string, a warning is printed and [NaI] is returned. The parser is case unsensitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; parse(DecoratedInterval{Float64}, &quot;[1, 2]&quot;)
[1, 2]_com

julia&gt; parse(DecoratedInterval{Float64}, &quot;[1, 2]_def&quot;)
[1, 2]_def</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/parsing.jl#L91-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.round-Tuple{Interval}" href="#Base.round-Tuple{Interval}"><code>Base.round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round(a::Interval[, RoundingMode])</code></pre><p>Return the interval with limits rounded to an integer.</p><p>Implement the functions <code>roundTiesToEven</code> and <code>roundTiesToAway</code> of the IEEE Standard 1788-2015.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/integer.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setdiff(x::Interval, y::Interval)</code></pre><p>Calculate the set difference <code>x ∖ y</code>, i.e. the set of values that are inside the interval <code>x</code> but not inside <code>y</code>.</p><p>Returns an array of intervals. The array may:</p><ul><li>be empty if <code>x ⊆ y</code>;</li><li>contain a single interval, if <code>y</code> overlaps <code>x</code></li><li>contain two intervals, if <code>y</code> is strictly contained within <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/set_operations.jl#L74-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, IntervalBox{N, T}}} where {N, T&lt;:Union{AbstractFloat, Rational}}" href="#Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, IntervalBox{N, T}}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setdiff(A::IntervalBox{N,T}, B::IntervalBox{N,T})</code></pre><p>Returns a vector of <code>IntervalBox</code>es that are in the set difference <code>A ∖ B</code>, i.e. the set of <code>x</code> that are in <code>A</code> but not in <code>B</code>.</p><p>Algorithm: Start from the total overlap (in all directions); expand each direction in turn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/setdiff.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.sign-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(a::Interval)</code></pre><p>Implement the <code>sign</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/integer.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.signbit-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.signbit-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.signbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signbit(a::Interval)</code></pre><p>Return an interval containing 1 if any element in <code>a</code> is negative and containing 0 if any element in <code>a</code> is positive. An empty interval is returned if <code>a</code> is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; signbit(interval(-4))
Interval{Float64}(1.0, 1.0)

julia&gt; signbit(interval(5))
Interval{Float64}(0.0, 0.0)

julia&gt; signbit(interval(-4,5))
Interval{Float64}(0.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/signbit.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sin-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.sin-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sin(a::Interval)</code></pre><p>Implement the <code>sin</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sinh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.sinh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sinh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sinh(a::Interval)</code></pre><p>Implement the <code>sinh</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sqrt-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.sqrt-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sqrt(a::Interval)</code></pre><p>Square root of an interval.</p><p>Implement the <code>sqrt</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tan-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.tan-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.tan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tan(a::Interval)</code></pre><p>Implement the <code>tan</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tanh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.tanh-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.tanh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tanh(a::Interval)</code></pre><p>Implement the <code>tanh</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/hyperbolic.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.trunc-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#Base.trunc-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>Base.trunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trunc(a::Interval)</code></pre><p>Implement the <code>trunc</code> function of the IEEE Standard 1788-2015 (Table 9.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/integer.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">union(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/functions.jl#L264-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Tuple{Union{Complex{&lt;:Interval}, Interval}, Union{Complex{&lt;:Interval}, Interval}}" href="#Base.union-Tuple{Union{Complex{&lt;:Interval}, Interval}, Union{Complex{&lt;:Interval}, Interval}}"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">union(a, b)
∪(a,b)</code></pre><p>Return the union (convex hull) of the intervals <code>a</code> and <code>b</code>; it is equivalent to <code>hull(a,b)</code>.</p><p>Implement the <code>converxHull</code> function of the IEEE Standard 1788-2015 (Section 9.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/set_operations.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Union{Tuple{Type{IntervalBox{N, T}}}, Tuple{T}, Tuple{N}} where {N, T&lt;:Union{AbstractFloat, Rational}}" href="#Base.zero-Union{Tuple{Type{IntervalBox{N, T}}}, Tuple{T}, Tuple{N}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero(IntervalBox{N, T})</code></pre><p>Return the zero interval box of dimension <code>N</code> in the numeric type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/intervalbox.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.:±-Tuple{Any, Any}" href="#IntervalArithmetic.:±-Tuple{Any, Any}"><code>IntervalArithmetic.:±</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">±(m, r)
m ± r</code></pre><p>Create the interval <span>$[m - r, m + r]$</span> according to the IEEE Standard 1788-2015. Despite using the midpoint-radius notation, the returned interval is still an <code>Interval</code> represented by its bounds.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Nothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, use the string macro <a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>@I_str</code></a> to ensure tight enclosure around the typed numbers.</p></div></div><p>See also: <a href="#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>interval</code></a>, <a href="@ref"><code>..</code></a> and <a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>@I_str</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; 0 ± π
Interval{Float64}(-3.1415926535897936, 3.1415926535897936)

julia&gt; 0//1 ± π
Interval{Rational{Int64}}(-85563208//27235615, 85563208//27235615)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L193-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.:≛-Tuple{Interval, Interval}" href="#IntervalArithmetic.:≛-Tuple{Interval, Interval}"><code>IntervalArithmetic.:≛</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">≛(a::Interval, b::Interval)</code></pre><p>Checks if the intervals <code>a</code> and <code>b</code> are identical.</p><p>Typed as \starequal&lt;TAB&gt;.</p><p>Implement the <code>equal</code> function of the IEEE Standard 1788-2015  (Table 9.3).</p><p>The more common <code>==</code> operator is reserved for flavor dependent pointwise equality.</p><p>In most case this is equivalent to the built-in <code>===</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.:≛-Tuple{Interval, Real}" href="#IntervalArithmetic.:≛-Tuple{Interval, Real}"><code>IntervalArithmetic.:≛</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">≛(a::Interval, x::Real)</code></pre><p>Check if the interval <code>a</code> contains exactly (and only) the number <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.:⊂-Tuple{Interval, Interval}" href="#IntervalArithmetic.:⊂-Tuple{Interval, Interval}"><code>IntervalArithmetic.:⊂</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊂(a,b)</code></pre><p>Checks if <code>a</code> is a strict subset of interval <code>b</code>.</p><p>Typed with \subset&lt;TAB&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic._parse-Union{Tuple{T}, Tuple{Type{Interval{T}}, AbstractString}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic._parse-Union{Tuple{T}, Tuple{Type{Interval{T}}, AbstractString}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic._parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_parse(::Type{Interval{T}}, s::AbstractString) where T</code></pre><p>tries to parse the string <code>s</code> to an interval of type <code>Interval{T}</code> and throws an argument error if an invalid string is given.</p><p><strong>Output</strong></p><ul><li>the parsed interval</li><li>a flag <code>isnotcom</code>, which is set to true if the input interval is not <code>com</code> and to false otherwise. This is used to distinguish the case when an interval is supposed to be unbounded (e.g. input <code>&quot;[3, infinity]&quot;</code>) or becomes unbounded because of overflow (e.g. the input <code>&quot;[3, 1e400]&quot;, which is parse to</code>[3, ∞]<code>when using</code>Float64`).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/parsing.jl#L155-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic._setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic._setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic._setdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_setdiff(x::Interval{T}, y::Interval{T})</code></pre><p>Computes the set difference x\y and always returns a tuple of two intervals. If the set difference is only one interval or is empty, then the returned tuple contains 1 or 2 empty intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/setdiff.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.atomic-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.atomic-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.atomic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomic(T&lt;:Union{Rational,AbstractFloat}, a)</code></pre><p>Create an interval according to the IEEE Standard 1788-2015. The returned <code>Interval{T}</code> always contains the value <code>a</code> but its construction depends on its type. If <code>a</code> is an <code>AbstractString</code>, then the interval is constructed by calling <a href="#Base.parse-Union{Tuple{F}, Tuple{Type{F}, AbstractString}} where F&lt;:Interval"><code>parse</code></a>. If <code>a</code> is an <code>AbstractFloat</code>, the interval is widen to two eps to be sure to contain the number that was typed in. In all other cases, this is semantically equivalent to <code>interval(T, a)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; IntervalArithmetic.atomic(Float64, 0.1)
Interval{Float64}(0.09999999999999999, 0.10000000000000002)

julia&gt; IntervalArithmetic.atomic(Float64, 0.1)
Interval{Float64}(0.29999999999999993, 0.30000000000000004)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L229-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.bigequiv-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.bigequiv-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.bigequiv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bigequiv(x::Interval)
bigequiv(x::Union{Rational,AbstractFloat})</code></pre><p>Create a <code>BigFloat</code> equivalent with the same underlying precision as <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L270-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.bisect" href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bisect(X::IntervalBox, α=0.49609375)</code></pre><p>Bisect the <code>IntervalBox</code> <code>X</code> at position α ∈ [0,1] along its longest side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/bisect.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.bisect" href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bisect(X::IntervalBox, i::Integer, α=0.49609375)</code></pre><p>Bisect the <code>IntervalBox</code> in side number <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/bisect.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.bisect-Union{Tuple{Interval{T}}, Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.bisect-Union{Tuple{Interval{T}}, Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisect(X::Interval, α=0.49609375)</code></pre><p>Split the interval <code>X</code> at position α; α=0.5 corresponds to the midpoint. Returns a tuple of the new intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/bisect.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.bounds-Tuple{Interval}" href="#IntervalArithmetic.bounds-Tuple{Interval}"><code>IntervalArithmetic.bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounds(a::Interval)</code></pre><p>Bounds of an interval as a tuple. This is semantically equivalent to <code>(a.lo, sup(a))</code>. In particular, this function does not normalize the lower bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.cancelminus" href="#IntervalArithmetic.cancelminus"><code>IntervalArithmetic.cancelminus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cancelminus(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/functions.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.cancelminus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cancelminus(a, b)</code></pre><p>Return the unique interval <code>c</code> such that <code>b + c = a</code>.</p><p>Implement the <code>cancelMinus</code> function of the IEEE Standard 1788-2015 (Section 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/cancellative.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.cancelplus" href="#IntervalArithmetic.cancelplus"><code>IntervalArithmetic.cancelplus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cancelplus(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/functions.jl#L236-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.cancelplus-Tuple{Interval, Interval}" href="#IntervalArithmetic.cancelplus-Tuple{Interval, Interval}"><code>IntervalArithmetic.cancelplus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cancelplus(a, b)</code></pre><p>Return the unique interval <code>c</code> such that <code>b - c = a</code>.</p><p>Equivalent to <code>cancelminus(a, -b)</code>.</p><p>Implement the <code>cancelPlus</code> function of the IEEE Standard 1788-2015 (Section 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/cancellative.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.default_numtype-Tuple{}" href="#IntervalArithmetic.default_numtype-Tuple{}"><code>IntervalArithmetic.default_numtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_numtype()</code></pre><p>Return the default bound type used in <a href="#IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>promote_numtype</code></a>. By default, <code>default_numtype()</code> is set to <code>Float64</code>. It can be modified by redefining the function, however it should be set to a concrete subtype of <code>Rational</code> or <code>AbstractFloat</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; IntervalArithmetic.default_numtype()
Float64

julia&gt; typeof(interval(1, 2))
Interval{Float64}

julia&gt; typeof(interval(1, big(2)))
Interval{BigFloat}

julia&gt; IntervalArithmetic.default_numtype() = Float32

julia&gt; typeof(interval(1, 2))
Interval{Float32}

julia&gt; typeof(interval(1, big(2)))
Interval{BigFloat}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L58-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.diam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diam(a::Interval)</code></pre><p>Return the diameter (length) of the interval <code>a</code>.</p><p>Implement the <code>wid</code> function of the IEEE Standard 1788-2015 (Table 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.div_by_thin_zero-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.div_by_thin_zero-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.div_by_thin_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_by_thin_zero(::Flavor, x::Interval)</code></pre><p>Divide <code>x</code> by the interval containing only <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/flavors.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.emptyinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.emptyinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.emptyinterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emptyinterval</code></pre><p><code>emptyinterval</code>s are represented as the interval [∞, -∞]; note that this interval is an exception to the fact that the lower bound is larger than the upper one.</p><p>Note that if the type of the returned interval can not be inferred from the argument given, the default interval bound type is used.</p><p>Implement the <code>empty</code> function of the IEEE Standard 1788-2015 (Section 10.5.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/constants.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.entireinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.entireinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.entireinterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entireinterval</code></pre><p><code>RR</code> represent the entire real line [-Inf, Inf].</p><p>Depending on the flavor, <code>-Inf</code> and <code>Inf</code> may or may not be considerd inside this interval.</p><p>Note that if the type of the returned interval can not be inferred from the argument given, the default interval flavor will be used. See the documentation of <code>Interval</code> for more information about the default interval falvor.</p><p>Implement the <code>entire</code> function of the IEEE Standard 1788-2015 (Section 10.5.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/constants.jl#L24-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.extended_div</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extended_div(a::Interval, b::Interval)</code></pre><p>Two-output division.</p><p>Implement the <code>mulRevToPair</code> function of the IEEE Standard 1788-2015 (Section 10.5.5).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/extended_div.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.find_quadrants</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_quadrants(x)</code></pre><p>Finds the quadrant(s) corresponding to a given floating-point number. The quadrants are labelled as 0 for x ∈ [0, π/2], etc. A tuple of two quadrants is returned. The minimum or maximum must then be chosen appropriately.</p><p>This is a rather indirect way to determine if π/2 and 3π/2 are contained in the interval; cf. the formula for sine of an interval in Tucker, <em>Validated Numerics</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/trigonometric.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.hull" href="#IntervalArithmetic.hull"><code>IntervalArithmetic.hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hull(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/functions.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.hull-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}" href="#IntervalArithmetic.hull-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hull(a, b)</code></pre><p>Return the &quot;interval hull&quot; of the intervals <code>a</code> and <code>b</code>, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of <code>a</code> and <code>b</code>.</p><p>Implement the <code>converxHull</code> function of the IEEE Standard 1788-2015 (Section 9.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/set_operations.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.inf-Tuple{Interval}" href="#IntervalArithmetic.inf-Tuple{Interval}"><code>IntervalArithmetic.inf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inf(a::Interval)</code></pre><p>Infimum of an interval. For a zero <code>AbstractFloat</code> lower bound, a negative zero is returned.</p><p>Implement the <code>inf</code> function of the IEEE Standard 1788-2015 (Table 9.2 and Section 12.12.8).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.interval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interval([T&lt;:Union{Rational,AbstractFloat}=default_numtype()], a, b)</code></pre><p>Create the interval <span>$[a, b]$</span> according to the IEEE Standard 1788-2015. The validity of the interval is checked by <a href="#IntervalArithmetic.is_valid_interval-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>is_valid_interval</code></a>: if <code>true</code> then an <code>Interval{T}</code> is constructed, otherwise a warning is printed and the empty interval is returned.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Nothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, use the string macro <a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>@I_str</code></a> to ensure tight enclosure around the typed numbers.</p></div></div><p>See also: <a href="#IntervalArithmetic.:±-Tuple{Any, Any}"><code>±</code></a>, <a href="@ref"><code>..</code></a> and <a href="#IntervalArithmetic.@I_str-Tuple{Any}"><code>@I_str</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setformat(:full);

julia&gt; interval(1//1, π)
Interval{Rational{Int64}}(1//1, 85563208//27235615)

julia&gt; interval(Rational{Int32}, 1//1, π)
Interval{Rational{Int32}}(1//1, 85563208//27235615)

julia&gt; interval(1, π)
Interval{Float64}(1.0, 3.1415926535897936)

julia&gt; interval(BigFloat, 1, π)
Interval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L112-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.is_valid_interval-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.is_valid_interval-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}, Any, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.is_valid_interval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_valid_interval(a, b)</code></pre><p>Check if <code>(a, b)</code> constitute a valid interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/flavors.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isatomic-Tuple{Interval}" href="#IntervalArithmetic.isatomic-Tuple{Interval}"><code>IntervalArithmetic.isatomic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isatomic(x::Interval)</code></pre><p>Check whether an interval <code>x</code> is <em>atomic</em>, i.e. is unable to be split. This occurs when the interval is empty, or when the upper bound equals the lower bound or the bounds are consecutive floating point numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.iscommon-Tuple{Interval}" href="#IntervalArithmetic.iscommon-Tuple{Interval}"><code>IntervalArithmetic.iscommon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iscommon(x)</code></pre><p>Checks if <code>x</code> is a <strong>common interval</strong>, i.e. a non-empty, bounded, real interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isinterior-Tuple{Interval, Interval}" href="#IntervalArithmetic.isinterior-Tuple{Interval, Interval}"><code>IntervalArithmetic.isinterior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinterior(a,b)</code></pre><p>Checks if all the points of the interval <code>a</code> are within the interior of interval <code>b</code>.</p><p>Implement the <code>interior</code> function of the IEEE Standard 1788-2015 (Table 9.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isstrictless-Tuple{Interval, Interval}" href="#IntervalArithmetic.isstrictless-Tuple{Interval, Interval}"><code>IntervalArithmetic.isstrictless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isstrictless(a, b)</code></pre><p>Checks if the interval <code>a</code> is strictly less than interval <code>b</code>, which is true if <code>inf(a) &lt; inf(b)</code> and <code>sup(a) &lt; sup(b)</code>.</p><p>For variants in the definition of &quot;strictly less than&quot; for intervals see <code>strictprecedes</code> and <code>&lt;</code>.</p><p>Implement the <code>strictLess</code> function of the IEEE Standard 1788-2015 (Table 10.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L110-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isthin-Tuple{Interval}" href="#IntervalArithmetic.isthin-Tuple{Interval}"><code>IntervalArithmetic.isthin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isthin(x)</code></pre><p>Checks if <code>x</code> is the set consisting of a single exactly representable float. Any float which is not exactly representable does <em>not</em> yield a thin interval. Corresponds to <code>isSingleton</code> of the standard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L180-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isthininteger-Tuple{Interval}" href="#IntervalArithmetic.isthininteger-Tuple{Interval}"><code>IntervalArithmetic.isthininteger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isthininteger(x)</code></pre><p>Return whether the inverval only contains a single integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isthinzero-Tuple{Interval}" href="#IntervalArithmetic.isthinzero-Tuple{Interval}"><code>IntervalArithmetic.isthinzero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isthinzero(x)</code></pre><p>Return whether the interval only contains zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.isweaklyless-Tuple{Interval, Interval}" href="#IntervalArithmetic.isweaklyless-Tuple{Interval, Interval}"><code>IntervalArithmetic.isweaklyless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isweaklyless(a, b)</code></pre><p>Checks if the interval <code>a</code> is weakly less than interval <code>b</code>.</p><p>Note that this is not equivalent as saying every element of <code>a</code> is less than any element of <code>b</code>.</p><p>Implement the <code>less</code> function of the IEEE Standard 1788-2015 (Table 10.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mag-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.mag-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mag(a::Interval)</code></pre><p>Magnitude of an interval. Return <code>NaN</code> for empty intervals.</p><p>Implement the <code>mag</code> function of the IEEE Standard 1788-2015 (Table 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mid-Tuple{IntervalBox}" href="#IntervalArithmetic.mid-Tuple{IntervalBox}"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid(X::IntervalBox, α=0.5)</code></pre><p>Return a vector of the <code>mid</code> of each interval composing the <code>IntervalBox</code>.</p><p>See <code>mid(X::Interval, α=0.5)</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/intervalbox.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid(a::Interval)</code></pre><p>Find the midpoint of the interval <code>a</code>.</p><p>Implement the <code>mid</code> function of the IEEE Standard 1788-2015 (Table 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.midpoint_radius-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.midpoint_radius-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.midpoint_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>midpoint_radius(a::Interval)</p><p>Return the midpoint of an interval <code>a</code> together with its radius.</p><p>Function required by the IEEE Standard 1788-2015 in Section 10.5.9 for the set-based flavor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L122-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mig-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.mig-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mig(a::Interval)</code></pre><p>Mignitude of an interval. Return <code>NaN</code> for empty intervals.</p><p>Implement the <code>mig</code> function of the IEEE Standard 1788-2015 (Table 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mince-Union{Tuple{N}, Tuple{IntervalBox{N}, Int64}} where N" href="#IntervalArithmetic.mince-Union{Tuple{N}, Tuple{IntervalBox{N}, Int64}} where N"><code>IntervalArithmetic.mince</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mince(x::IntervalBox, n::Int)</code></pre><p>Splits <code>x</code> in <code>n</code> intervals in each dimension of the same diameter. These intervals are combined in all possible <code>IntervalBox</code>-es, which are returned as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/intervalbox.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mince-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.mince</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mince(x::Interval, n)</code></pre><p>Split <code>x</code> in <code>n</code> intervals of the same diameter, which are returned as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/bisect.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Any}} where {N, T&lt;:Union{AbstractFloat, Rational}}" href="#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Any}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.mince</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mince(x::IntervalBox, n)</code></pre><p>Split <code>x</code> in <code>n</code> intervals in each dimension of the same diameter. These intervals are combined in all possible <code>IntervalBox</code>-es, which are returned as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/bisect.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Tuple{Vararg{Int64, N}}}} where {N, T&lt;:Union{AbstractFloat, Rational}}" href="#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Tuple{Vararg{Int64, N}}}} where {N, T&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.mince</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mince(x::IntervalBox, ncuts::::NTuple{N,Int})</code></pre><p>Splits <code>x[i]</code> in <code>ncuts[i]</code> intervals . These intervals are combined in all possible <code>IntervalBox</code>-es, which are returned as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/intervalbox.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.nai</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>NaI</code> not-an-interval: [NaN, NaN].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/decorations/decorations.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.nthroot-Tuple{Interval{BigFloat}, Integer}" href="#IntervalArithmetic.nthroot-Tuple{Interval{BigFloat}, Integer}"><code>IntervalArithmetic.nthroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nthroot(a::Interval, n::Integer)</code></pre><p>Compute the real n-th root of Interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/power.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.numtype-Tuple{F} where F" href="#IntervalArithmetic.numtype-Tuple{F} where F"><code>IntervalArithmetic.numtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numtype(::T)
numtype(::Type{T})</code></pre><p>Return the type <code>T</code> of the bounds of the interval.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; IntervalArithmetic.numtype(interval(1, 2))
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/real_interface.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.overlap-Tuple{Interval, Interval}" href="#IntervalArithmetic.overlap-Tuple{Interval, Interval}"><code>IntervalArithmetic.overlap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap(a::Interval, b::Interval)</code></pre><p>Implement the <code>overlap</code> function according to the IEEE Standard 1788-2015 (Section 10.6.4 and Table 10.7).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/overlap.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.parse_num-Union{Tuple{T}, Tuple{S}, Tuple{Type{T}, AbstractString, RoundingMode{:Down}}} where {S&lt;:Integer, T&lt;:Rational{S}}" href="#IntervalArithmetic.parse_num-Union{Tuple{T}, Tuple{S}, Tuple{Type{T}, AbstractString, RoundingMode{:Down}}} where {S&lt;:Integer, T&lt;:Rational{S}}"><code>IntervalArithmetic.parse_num</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Same as <code>parse(T, s, rounding_mode)</code>, but also accept string representing rational numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/parsing.jl#L246-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.pow-Union{Tuple{T}, Tuple{Interval{T}, Integer}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.pow-Union{Tuple{T}, Tuple{Interval{T}, Integer}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.pow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pow(x::Interval, n::Integer)</code></pre><p>A faster implementation of <code>x^n</code>, currently using <code>power_by_squaring</code>. <code>pow(x, n)</code> will usually return an interval that is slightly larger than that calculated by <code>x^n</code>, but is guaranteed to be a correct enclosure when using multiplication with correct rounding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/power.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.precedes-Tuple{Interval, Interval}" href="#IntervalArithmetic.precedes-Tuple{Interval, Interval}"><code>IntervalArithmetic.precedes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precedes(a, b)</code></pre><p>Checks if the interval <code>a</code> is to the left of interval <code>b</code>.</p><p>Implement the <code>precedes</code> function of the IEEE Standard 1788-2015 (Table 10.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}" href="#IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T&lt;:Union{AbstractFloat, Rational}, S&lt;:Union{AbstractFloat, Rational}}"><code>IntervalArithmetic.promote_numtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_numtype(T, S)</code></pre><p>Return the bound type used to construct intervals. The bound type is given by <code>promote_type(T, S)</code> if <code>T</code> or <code>S</code> is a <code>Rational</code> or an <code>AbstractFloat</code>; except when <code>T</code> is a <code>Rational{R}</code> and <code>S</code> is an <code>AbstractIrrational</code> (or vice-versa), in which case the bound type is given by <code>Rational{promote_type(R, Int64)}</code>. In all other cases, the bound type is given by <code>promote_type(default_numtype(), T, S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/construction.jl#L88-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.radius-Tuple{Interval}" href="#IntervalArithmetic.radius-Tuple{Interval}"><code>IntervalArithmetic.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius(a::Interval)</code></pre><p>Return the radius of the interval <code>a</code>, such that <code>a ⊆ m ± radius</code>, where <code>m = mid(a)</code> is the midpoint.</p><p>Implement the <code>rad</code> function of the IEEE Standard 1788-2015 (Table 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.round_expr-Tuple{Expr, RoundingMode}" href="#IntervalArithmetic.round_expr-Tuple{Expr, RoundingMode}"><code>IntervalArithmetic.round_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_expr(ex::Expr, rounding_mode::RoundingMode)</code></pre><p>Transforms a single expression by applying a rounding mode, e.g.</p><ul><li><code>a + b</code> into <code>+(a, b, RoundDown)</code></li><li><code>sin(a)</code> into <code>sin(a, RoundDown)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/rounding_macros.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.scaled_mid-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.scaled_mid-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.scaled_mid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaled_mid(a::Interval, α)</code></pre><p>Find an intermediate  point at a relative position <code>α</code> in the interval <code>a</code> instead.</p><p>Assume 0 ≤ α ≤ 1.</p><p>Note that <code>scaled_mid(a, 0.5)</code> does not equal <code>mid(a)</code> for unbounded set-based intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.setformat" href="#IntervalArithmetic.setformat"><code>IntervalArithmetic.setformat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setformat(format::Symbol; decorations::Bool, sigdigits::Int)
setformat()</code></pre><p>Change the format used by <code>show</code> to display intervals.</p><p>Initially, the display options are <code>format = :standard</code>, <code>decorations = false</code> and <code>sigdigits = 6</code>.</p><p>If any of the three argument <code>format</code>, <code>decorations</code> and <code>sigdigits</code> is omitted, then their value is left unchanged.</p><p>If the three arguments are omitted, i.e. calling <code>setformat()</code>, then the values are reset to the default display options.</p><p>Possible options:</p><ul><li><code>format</code> can be:<ul><li><code>:standard</code>: <code>[1, 2]</code>.</li><li><code>:midpoint</code>: display <code>x::Interval</code> in the form &quot;mid(x) ± radius(x)&quot;.</li><li><code>:full</code>: display the entire bounds regardless of <code>sigdigits</code>.</li></ul></li><li><code>sigdigits</code>: number (greater or equal to 1) of significant digits to display.</li><li><code>decorations</code>: display the decorations or not.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; x = interval(0.1, 0.3)  # Default display options
[0.0999999, 0.300001]

julia&gt; setformat(:full)
Display parameters:
  - format: full
  - decorations: true
  - significant digits: 6

julia&gt; x
Interval(0.09999999999999999, 0.30000000000000004)

julia&gt; setformat(:standard; sigdigits = 3)
Display parameters:
  - format: standard
  - decorations: true
  - significant digits: 3

julia&gt; x
[0.0999, 0.301]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/display.jl#L16-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.strictprecedes-Tuple{Interval, Interval}" href="#IntervalArithmetic.strictprecedes-Tuple{Interval, Interval}"><code>IntervalArithmetic.strictprecedes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strictprecedes(a, b)</code></pre><p>Checks if the interval <code>a</code> is strictly to the left of interval <code>b</code>.</p><p>Implement the <code>strictPrecedes</code> function of the IEEE Standard 1788-2015 (Table 10.3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/boolean.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.sup-Tuple{Interval}" href="#IntervalArithmetic.sup-Tuple{Interval}"><code>IntervalArithmetic.sup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sup(a::Interval)</code></pre><p>Supremum of an interval.</p><p>Implement the <code>sup</code> function of the IEEE Standard 1788-2015 (Table 9.2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/interval_operations/numeric.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.symmetric_box-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.symmetric_box-Union{Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.symmetric_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetric_box(N, T)</code></pre><p>Return the symmetric interval box of dimension <code>N</code> in the numeric type <code>T</code>, each side is <code>Interval(-1, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/multidim/intervalbox.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.unsafe_scale-Union{Tuple{T}, Tuple{T, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.unsafe_scale-Union{Tuple{T}, Tuple{T, Interval{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.unsafe_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_scale(α, a::Interval)</code></pre><p>Multiply an interval by a positive scalar. For efficiency, does not check that the constant is positive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/arithmetic/basic.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.zero_times_infinity-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}}} where T&lt;:Union{AbstractFloat, Rational}" href="#IntervalArithmetic.zero_times_infinity-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}}} where T&lt;:Union{AbstractFloat, Rational}"><code>IntervalArithmetic.zero_times_infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_times_infinity(::Flavor, ::Type{T})</code></pre><p>Return the result of zero times positive infinity for the given flavor and number type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/intervals/flavors.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalArithmetic.Region" href="#IntervalArithmetic.Region"><code>IntervalArithmetic.Region</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Region{T} = Union{Interval{T}, IntervalBox{T}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIntervals/IntervalArithmetic.jl/blob/579ecbe8c7e1c841b078d59c8ba210a60eff586e/src/IntervalArithmetic.jl#L108-L110">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rounding/">« Rounding</a><a class="docs-footer-nextpage" href="../input_output/">Input&amp;Output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 28 August 2023 10:51">Monday 28 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

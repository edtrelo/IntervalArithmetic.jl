var documenterSearchIndex = {"docs":
[{"location":"intro/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"intro/","page":"Overview","title":"Overview","text":"The basic idea in interval arithmetic is to perform computations with a whole interval of real numbers","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"a b bydef x in mathbbR a le x le b ","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"where a b in mathbbR cup  pm infty ; note that despite the above notation, a b does not contain infinity when a or b are infinite.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"We define functions on intervals in such a way that the result of the computation is a new interval that is guaranteed to contain the true range of the function.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"For instance, by monotonicity, the exponential function is given by","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"e^a b bydef e^a e^b","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"On the other hand, the squaring function is non-monotone, thus it is given by the following cases","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"a b^2 bydef\nbegincases\na^2 b^2   0  a  b\n0 max(a^2 b^2)  a  0  b\nb^2 a^2  a  b  0\nendcases","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Of course, we must round the lower endpoint down and the upper endpoint up to get a guaranteed enclosure of the true result.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"IntervalArithmetic defines such behaviour for a wide set of basic functions, thereby allowing the evaluation of more complex functions such as","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"f(x) = sin(3x^2 - 2 cos(1x))","category":"page"},{"location":"intro/#Applications","page":"Overview","title":"Applications","text":"","category":"section"},{"location":"intro/","page":"Overview","title":"Overview","text":"To illustrate the use of interval arithmetic, consider the following:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"using IntervalArithmetic\nf(x) = x^2 - 2\nx = interval(3, 4)\nf(x)","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Since f(x) does not contain 0, the true range of the function f over the interval 3 4 is guaranteed not to contain 0, and hence we obtain the following property.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Theorem: f has no root in the interval 3 4.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"This theorem has been obtained using floating-point computations! In fact, we can even extend this to semi-infinite intervals:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"f(interval(3, Inf))","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Therefore, we have excluded the whole unbounded set 3 infty) from possibly containing roots of f.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Interval arithmetic is the foundation of more powerful and elaborate methods in the field of computer-assisted proofs (see e.g. IntervalRootFinding.jl).","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"The interested reader may refer to the following books:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"R. E. Moore, R. B. Kearfott and M. J. Cloud, Introduction to Interval Analysis, Society for Industrial and Applied Mathematics (2009)\nW. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press (2010)","category":"page"},{"location":"manual/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"Modules = [IntervalArithmetic]\nOrder   = [:type, :function, :macro, :constant]","category":"page"},{"location":"manual/api/#IntervalArithmetic.DECORATION","page":"API","title":"IntervalArithmetic.DECORATION","text":"DECORATION\n\nEnumeration constant for the types of interval decorations. The nomenclature follows Section 11.2 of the IEEE Standard 1788-2015:\n\ncom -> 4: non-empty, continuous and bounded (common)\ndac -> 3: non-empty and continuous (defined and continuous)\ndef -> 2: non-empty (defined)\ntrv -> 1: always true (trivial)\nill -> 0: not an interval (ill-formed)\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.DecoratedInterval","page":"API","title":"IntervalArithmetic.DecoratedInterval","text":"DecoratedInterval{T<:NumTypes}\n\nWraps an Interval together with a DECORATION, i.e. a flag that records the status of the interval when thought of as the result of a previously executed sequence of functions acting on an initial interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Flavor","page":"API","title":"IntervalArithmetic.Flavor","text":"Flavor{F}\n\nSuper type of all interval flavors.\n\nA flavor defines (following the IEEE Std 1788-2015) how an interval behaves in edge cases. This mostly makes a difference when dealing with infinity and division by zero.\n\nCurrently only Flavor{:set_based} is supported.\n\n:set_based (default) : Elements of an interval are real number.   In particular, infinity is never part of an interval and is only used as a   shorthand.   For example, the interval (2..Inf) contain all real number greater than 2.   In particular, this means that (Inf..Inf) is an empty interval, and division   by a thin zero returns the empty interval.   The edge cases are       - x/(0..0) ≛ ∅       - (0..0)/(0..0) ≛ ∅       - (0..0)*(-Inf..Inf) ≛ 0       - Inf ∈ (0..Inf) == false   This flavor is described and required in part 2 of the IEEE Std 1799-2015.\n:cset (not implemented) : Elements of an interval are either real numbers   or ±Inf, applying standard rule for arithmetic with infinity.   The edge cases are       - x/(0..0) ≛ (-Inf..Inf)       - (0..0)/(0..0) ≛ (-Inf..Inf)       - (0..0)*(-Inf..Inf) ≛ (-Inf..Inf)       - Inf ∈ (0..Inf) == true\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Interval","page":"API","title":"IntervalArithmetic.Interval","text":"Interval{T<:NumTypes} <: Real\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015.\n\nFields:\n\nlo::T\nhi::T\n\nConstructors compliant with the IEEE Standard 1788-2015:\n\ninterval\n..\n±\n@I_str\n\nwarning: Warning\nThe internal constructor unsafe_interval is not compliant with the IEEE Standard 1788-2015.\n\nSee also: interval, ±, .. and @I_str.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.IntervalBox","page":"API","title":"IntervalArithmetic.IntervalBox","text":"An IntervalBox is an N-dimensional rectangular box, given by a Cartesian product of a vector of N Intervals.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.IntervalRounding","page":"API","title":"IntervalArithmetic.IntervalRounding","text":"IntervalRounding{T}\n\nInterval rounding trait type.\n\nAllowed rounding types are\n\n:tight: fast, tight (correct) rounding with errorfree arithmetic via           FastRounding.jl.\n:accurate: fast \"accurate\" rounding using prevfloat and nextfloat              (slightly wider than needed).\n:slow: tight (correct) rounding by changing rounding mode (slow).\n:none: no rounding (for speed comparisons; no enclosure is guaranteed).\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#Base.:*-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:*","text":"*(a::Interval, b::Interval)\n*(a::Interval, b::Real)\n*(a::Real, b::Interval)\n\nImplement the mul function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of the multiplication is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:+-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:+","text":"+(a::Interval, b::Interval)\n+(a::Interval, b::Real)\n+(a::Real, b::Interval)\n\nImplement the add function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:--Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:-","text":"-(a::Interval)\n\nImplement the neg function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:--Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:-","text":"-(a::Interval, b::Interval)\n-(a::Interval, b::Real)\n-(a::Real, b::Interval)\n\nImplement the sub function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:/-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:/","text":"/(a::Interval, b::Interval)\n/(a::Interval, b::Real)\n/(a::Real, b::Interval)\n\nImplement the div function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of the division is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:^-Union{Tuple{F}, Tuple{F, F}} where F<:Interval","page":"API","title":"Base.:^","text":"^(a::Interval, b::Interval)\n^(a::Interval, b)\n\nImplement the pow function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.acot-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.acot","text":"acot(a::Interval)\n\nImplement the acot function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.acoth-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.acoth","text":"acoth(a::Interval)\n\nImplement the acoth function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.cot-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.cot","text":"cot(a::Interval)\n\nImplement the cot function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.coth-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.coth","text":"coth(a::Interval)\n\nImplement the coth function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.csc-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.csc","text":"csc(a::Interval)\n\nImplement the csc function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.csch-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.csch","text":"csch(a::Interval)\n\nImplement the csch function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.hypot-Tuple{Interval, Interval}","page":"API","title":"Base.Math.hypot","text":"hypot(x::Interval, n::Integer)\n\nDirect implemntation of hypot using intervals.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.sec-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.sec","text":"sec(a::Interval)\n\nImplement the sec function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.sech-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.sech","text":"sech(a::Interval)\n\nImplement the sech function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.abs-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.abs","text":"abs(a::Interval)\n\nImplement the abs function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.acos-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.acos","text":"acos(a::Interval)\n\nImplement the acos function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.acosh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.acosh","text":"acosh(a::Interval)\n\nImplement the acosh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.asin-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.asin","text":"asin(a::Interval)\n\nImplement the asin function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.asinh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.asinh","text":"asinh(a::Interval)\n\nImplement the asinh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.atan-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atan","text":"atan(a::Interval)\n\nImplement the atan function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.atanh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atanh","text":"atanh(a::Interval)\n\nImplement the atanh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.ceil-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.ceil","text":"ceil(a::Interval)\n\nImplement the ceil function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.cos-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.cos","text":"cos(a::Interval)\n\nImplement the cos function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.cosh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.cosh","text":"cosh(a::Interval)\n\nImplement the cosh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.floor-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.floor","text":"floor(a::Interval)\n\nImplement the floor function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.fma-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.fma","text":"fma(a::Interval, b::Interval, c::Interval)\n\nFused multiply-add.\n\nImplement the fma function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.hash-Tuple{Interval, UInt64}","page":"API","title":"Base.hash","text":"hash(x::Interval, h)\n\nCompute the integer hash code for an interval using the method for composite types used in AutoHashEquals.jl.\n\nNote that in IntervalArithmetic.jl, equality of intervals is given by ≛ rather than the == operator. The latter is reserved for the pointwise extension of equality to intervals and uses three-way logic by default.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.in-Tuple{Real, Interval}","page":"API","title":"Base.in","text":"in(x, a)\n∈(x, a)\n\nChecks if the number x is a member of the interval a, treated as a set.\n\nImplement the isMember function of the IEEE Standard 1788-2015 (section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.intersect","page":"API","title":"Base.intersect","text":"intersect(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#Base.intersect-Tuple{Union{Complex{<:Interval}, Interval}, Vararg{Union{Complex{<:Interval}, Interval}}}","page":"API","title":"Base.intersect","text":"intersect(a::Interval{T}...) where T\n\nReturn the n-ary intersection of its arguments.\n\nThis function is applicable to any number of input intervals, as in intersect(a1, a2, a3, a4) where ai is an interval. If your use case needs to splat the input, as in intersect(a...), consider reduce(intersect, a) instead, because you save the cost of splatting.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.intersect-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"Base.intersect","text":"intersect(a, b)\n∩(a,b)\n\nReturns the intersection of the intervals a and b, considered as (extended) sets of real numbers. That is, the set that contains the points common in a and b.\n\nImplement the intersection function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.inv-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.inv","text":"inv(a::Interval)\n\nImplement the recip function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of the division is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.isdisjoint-Tuple{Interval, Interval}","page":"API","title":"Base.isdisjoint","text":"isdisjoint(a,b)\n\nChecks if all the points of the interval a are within the interior of interval b.\n\nImplement the disjoint function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.issubset-Tuple{Interval, Interval}","page":"API","title":"Base.issubset","text":"⊆(a,b)\n\nChecks if all the points of the interval a are within the interval b.\n\nTyped with \\subseteq<TAB>.\n\nImplement the subset function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.max-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.max","text":"max(a::Interval, b::Interval)\n\nImplement the max function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.min-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.min","text":"min(a::Interval, b::Interval)\n\nImplement the min function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.parse-Union{Tuple{F}, Tuple{Type{F}, AbstractString}} where F<:Interval","page":"API","title":"Base.parse","text":"parse(Interval, s::AbstractString)\n\nCreate an interval according to the IEEE Standard 1788-2015. In contrast with constructors that do not use strings, this constructor guarantees that the returned interval tightly encloses the values described by the string, including numbers that have no exact float representation (e.g. 0.1).\n\nExamples of allowed string formats:\n\nI\"[1.33]\" or I\"1.33\": the interval containing 133.\nI\"[1.44, 2.78]\": the interval 144 278.\nI\"[empty]\": the empty interval.\nI\"[entire]\" or I\"[,]\": the interval -infty infty.\nI\"[3,]\": the interval 3 infty.\nI\"6.42?2\": the interval 64  644. The number after ? represents the   uncertainty in the last digit; by default this value is 0.5. The direction   of the uncertainty can be given by adding u or d at the end for the error   to only go up or down respectively (e.g. I\"4.5?5u\" represents 45 5).\nI\"6.42?2e2\": the interval 642 644.\nI\"3??u\": the interval 3 infty.\nI\"3??u\": the interval 3 infty.\nI\"3??\": the interval -infty infty.\n\nFor more details, see sections 9.7 and 12.11 of the IEEE Standard 1788-2015.\n\nExamples\n\njulia> setformat(:full);\n\njulia> parse(Interval{Float64}, \"[1, 2]\")\nInterval{Float64}(1.0, 2.0)\n\njulia> parse(Interval{Float64}, \"[1, 2]\")\nInterval{Float64}(1.0, 2.0)\n\njulia> parse(Interval{Float64}, \"[1,]\")\nInterval{Float64}(1.0, Inf)\n\njulia> parse(Interval{Float64}, \"[,]\")\nInterval{Float64}(-Inf, Inf)\n\njulia> parse(Interval{Float64}, \"6.42?2e2\")\nInterval{Float64}(640.0, 644.0)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}}, AbstractString}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.parse","text":"parse(DecoratedInterval, s::AbstractString)\n\nParse a string of the form \"[a, b]_dec\" as a DecoratedInterval with decoration dec. If the decoration is not specified, it is computed based on the parsed interval. If the input is an invalid string, a warning is printed and [NaI] is returned. The parser is case unsensitive.\n\nExamples\n\njulia> setformat(:full);\n\njulia> parse(DecoratedInterval{Float64}, \"[1, 2]\")\nDecoratedInterval(Interval{Float64}(1.0, 2.0), com)\n\njulia> parse(DecoratedInterval{Float64}, \"[1, 2]_def\")\nDecoratedInterval(Interval{Float64}(1.0, 2.0), def)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.round-Tuple{Interval}","page":"API","title":"Base.round","text":"round(a::Interval[, RoundingMode])\n\nReturn the interval with limits rounded to an integer.\n\nImplement the functions roundTiesToEven and roundTiesToAway of the IEEE Standard 1788-2015.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.setdiff","text":"setdiff(x::Interval, y::Interval)\n\nCalculate the set difference x ∖ y, i.e. the set of values that are inside the interval x but not inside y.\n\nReturns an array of intervals. The array may:\n\nbe empty if x ⊆ y;\ncontain a single interval, if y overlaps x\ncontain two intervals, if y is strictly contained within x.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, IntervalBox{N, T}}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"Base.setdiff","text":"setdiff(A::IntervalBox{N,T}, B::IntervalBox{N,T})\n\nReturns a vector of IntervalBoxes that are in the set difference A ∖ B, i.e. the set of x that are in A but not in B.\n\nAlgorithm: Start from the total overlap (in all directions); expand each direction in turn.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sign-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sign","text":"sign(a::Interval)\n\nImplement the sign function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.signbit-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.signbit","text":"signbit(a::Interval)\n\nReturn an interval containing 1 if any element in a is negative and containing 0 if any element in a is positive. An empty interval is returned if a is empty.\n\nExamples\n\njulia> setformat(:full);\n\njulia> signbit(interval(-4.0))\nInterval{Float64}(1.0, 1.0)\n\njulia> signbit(interval(5.0))\nInterval{Float64}(0.0, 0.0)\n\njulia> signbit(interval(-4.0, 5.0))\nInterval{Float64}(0.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sin-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sin","text":"sin(a::Interval)\n\nImplement the sin function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sinh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sinh","text":"sinh(a::Interval)\n\nImplement the sinh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sqrt-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sqrt","text":"sqrt(a::Interval)\n\nSquare root of an interval.\n\nImplement the sqrt function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.tan-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.tan","text":"tan(a::Interval)\n\nImplement the tan function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.tanh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.tanh","text":"tanh(a::Interval)\n\nImplement the tanh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.trunc-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.trunc","text":"trunc(a::Interval)\n\nImplement the trunc function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.union","page":"API","title":"Base.union","text":"union(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#Base.union-Tuple{Union{Complex{<:Interval}, Interval}, Union{Complex{<:Interval}, Interval}}","page":"API","title":"Base.union","text":"union(a, b)\n∪(a,b)\n\nReturn the union (convex hull) of the intervals a and b; it is equivalent to hull(a,b).\n\nImplement the converxHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.zero-Union{Tuple{Type{IntervalBox{N, T}}}, Tuple{T}, Tuple{N}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"Base.zero","text":"zero(IntervalBox{N, T})\n\nReturn the zero interval box of dimension N in the numeric type T.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.:±-Tuple{Any, Any}","page":"API","title":"IntervalArithmetic.:±","text":"±(m, r)\nm ± r\n\nCreate the interval m - r m + r according to the IEEE Standard 1788-2015. Despite using the midpoint-radius notation, the returned interval is still an Interval represented by its bounds.\n\nwarning: Warning\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, use the string macro @I_str to ensure tight enclosure around the typed numbers.\n\nSee also: interval, .. and @I_str.\n\nExamples\n\njulia> setformat(:full);\n\njulia> 0 ± π\nInterval{Float64}(-3.1415926535897936, 3.1415926535897936)\n\njulia> 0//1 ± π\nInterval{Rational{Int64}}(-85563208//27235615, 85563208//27235615)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.:≛-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.:≛","text":"≛(a::Interval, b::Interval)\n\nChecks if the intervals a and b are identical.\n\nTyped as \\starequal<TAB>.\n\nImplement the equal function of the IEEE Standard 1788-2015  (Table 9.3).\n\nThe more common == operator is reserved for flavor dependent pointwise equality.\n\nIn most case this is equivalent to the built-in ===.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.:≛-Tuple{Interval, Real}","page":"API","title":"IntervalArithmetic.:≛","text":"≛(a::Interval, x::Real)\n\nCheck if the interval a contains exactly (and only) the number x.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.:⊂-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.:⊂","text":"⊂(a,b)\n\nChecks if a is a strict subset of interval b.\n\nTyped with \\subset<TAB>.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._parse-Union{Tuple{T}, Tuple{Type{Interval{T}}, AbstractString}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._parse","text":"_parse(::Type{Interval{T}}, s::AbstractString) where T\n\ntries to parse the string s to an interval of type Interval{T} and throws an argument error if an invalid string is given.\n\nOutput\n\nthe parsed interval\na flag isnotcom, which is set to true if the input interval is not com and to false otherwise. This is used to distinguish the case when an interval is supposed to be unbounded (e.g. input \"[3, infinity]\") or becomes unbounded because of overflow (e.g. the input \"[3, 1e400]\", which is parse to[3, ∞]when usingFloat64`).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._setdiff","text":"_setdiff(x::Interval{T}, y::Interval{T})\n\nComputes the set difference x\\y and always returns a tuple of two intervals. If the set difference is only one interval or is empty, then the returned tuple contains 1 or 2 empty intervals.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.atomic-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.atomic","text":"atomic(T<:Union{Rational,AbstractFloat}, a)\n\nCreate an interval according to the IEEE Standard 1788-2015. The returned Interval{T} always contains the value a but its construction depends on its type. If a is an AbstractString, then the interval is constructed by calling parse. If a is an AbstractFloat, the interval is widen to two eps to be sure to contain the number that was typed in. In all other cases, this is semantically equivalent to interval(T, a).\n\nExamples\n\njulia> setformat(:full);\n\njulia> IntervalArithmetic.atomic(Float64, 0.1)\nInterval{Float64}(0.09999999999999999, 0.10000000000000002)\n\njulia> IntervalArithmetic.atomic(Float64, 0.3)\nInterval{Float64}(0.29999999999999993, 0.30000000000000004)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bigequiv-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bigequiv","text":"bigequiv(x::Interval)\nbigequiv(x::Union{Rational,AbstractFloat})\n\nCreate a BigFloat equivalent with the same underlying precision as x.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bisect","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(X::IntervalBox, α=0.49609375)\n\nBisect the IntervalBox X at position α ∈ [0,1] along its longest side.\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.bisect-2","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(X::IntervalBox, i::Integer, α=0.49609375)\n\nBisect the IntervalBox in side number i.\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.bisect-Union{Tuple{Interval{T}}, Tuple{T}, Tuple{Interval{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(X::Interval, α=0.49609375)\n\nSplit the interval X at position α; α=0.5 corresponds to the midpoint. Returns a tuple of the new intervals.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bounds-Tuple{Interval}","page":"API","title":"IntervalArithmetic.bounds","text":"bounds(a::Interval)\n\nBounds of an interval as a tuple. This is semantically equivalent to (a.lo, sup(a)). In particular, this function does not normalize the lower bound.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelminus","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(a, b)\n\nReturn the unique interval c such that b + c = a.\n\nImplement the cancelMinus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelplus","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.cancelplus-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(a, b)\n\nReturn the unique interval c such that b - c = a.\n\nEquivalent to cancelminus(a, -b).\n\nImplement the cancelPlus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.default_numtype-Tuple{}","page":"API","title":"IntervalArithmetic.default_numtype","text":"default_numtype()\n\nReturn the default bound type used in promote_numtype. By default, default_numtype() is set to Float64. It can be modified by redefining the function, however it should be set to a concrete subtype of Rational or AbstractFloat.\n\nExamples\n\njulia> IntervalArithmetic.default_numtype() = Float32\n\njulia> typeof(interval(1, 2))\nInterval{Float32}\n\njulia> typeof(interval(1, big(2)))\nInterval{BigFloat}\n\njulia> IntervalArithmetic.default_numtype() = Float64\n\njulia> typeof(interval(1, 2))\nInterval{Float64}\n\njulia> typeof(interval(1, big(2)))\nInterval{BigFloat}\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.diam","text":"diam(a::Interval)\n\nReturn the diameter (length) of the interval a.\n\nImplement the wid function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.div_by_thin_zero-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.div_by_thin_zero","text":"div_by_thin_zero(::Flavor, x::Interval)\n\nDivide x by the interval containing only 0.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.emptyinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.emptyinterval","text":"emptyinterval\n\nemptyintervals are represented as the interval [∞, -∞]; note that this interval is an exception to the fact that the lower bound is larger than the upper one.\n\nNote that if the type of the returned interval can not be inferred from the argument given, the default interval bound type is used.\n\nImplement the empty function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.entireinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.entireinterval","text":"entireinterval\n\nRR represent the entire real line [-Inf, Inf].\n\nDepending on the flavor, -Inf and Inf may or may not be considerd inside this interval.\n\nNote that if the type of the returned interval can not be inferred from the argument given, the default interval flavor will be used. See the documentation of Interval for more information about the default interval falvor.\n\nImplement the entire function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.extended_div","text":"extended_div(a::Interval, b::Interval)\n\nTwo-output division.\n\nImplement the mulRevToPair function of the IEEE Standard 1788-2015 (Section 10.5.5).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.find_quadrants","text":"find_quadrants(x)\n\nFinds the quadrant(s) corresponding to a given floating-point number. The quadrants are labelled as 0 for x ∈ [0, π/2], etc. A tuple of two quadrants is returned. The minimum or maximum must then be chosen appropriately.\n\nThis is a rather indirect way to determine if π/2 and 3π/2 are contained in the interval; cf. the formula for sine of an interval in Tucker, Validated Numerics.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.hull","page":"API","title":"IntervalArithmetic.hull","text":"hull(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.hull-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.hull","text":"hull(a, b)\n\nReturn the \"interval hull\" of the intervals a and b, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of a and b.\n\nImplement the converxHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.inf-Tuple{Interval}","page":"API","title":"IntervalArithmetic.inf","text":"inf(a::Interval)\n\nInfimum of an interval. For a zero AbstractFloat lower bound, a negative zero is returned.\n\nImplement the inf function of the IEEE Standard 1788-2015 (Table 9.2 and Section 12.12.8).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.interval","text":"interval([T<:Union{Rational,AbstractFloat}=default_numtype()], a, b)\n\nCreate the interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then an Interval{T} is constructed, otherwise a warning is printed and the empty interval is returned.\n\nwarning: Warning\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, use the string macro @I_str to ensure tight enclosure around the typed numbers.\n\nSee also: ±, .. and @I_str.\n\nExamples\n\njulia> setformat(:full);\n\njulia> interval(1//1, π)\nInterval{Rational{Int64}}(1//1, 85563208//27235615)\n\njulia> interval(Rational{Int32}, 1//1, π)\nInterval{Rational{Int32}}(1//1, 85563208//27235615)\n\njulia> interval(1, π)\nInterval{Float64}(1.0, 3.1415926535897936)\n\njulia> interval(BigFloat, 1, π)\nInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.is_valid_interval-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}, Any, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.is_valid_interval","text":"is_valid_interval(a, b)\n\nCheck if (a, b) constitute a valid interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isatomic-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isatomic","text":"isatomic(x::Interval)\n\nCheck whether an interval x is atomic, i.e. is unable to be split. This occurs when the interval is empty, or when the upper bound equals the lower bound or the bounds are consecutive floating point numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.iscommon-Tuple{Interval}","page":"API","title":"IntervalArithmetic.iscommon","text":"iscommon(x)\n\nChecks if x is a common interval, i.e. a non-empty, bounded, real interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isinterior-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.isinterior","text":"isinterior(a,b)\n\nChecks if all the points of the interval a are within the interior of interval b.\n\nImplement the interior function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isstrictless-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.isstrictless","text":"isstrictless(a, b)\n\nChecks if the interval a is strictly less than interval b, which is true if inf(a) < inf(b) and sup(a) < sup(b).\n\nFor variants in the definition of \"strictly less than\" for intervals see strictprecedes and <.\n\nImplement the strictLess function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x)\n\nChecks if x is the set consisting of a single exactly representable float. Any float which is not exactly representable does not yield a thin interval. Corresponds to isSingleton of the standard.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthininteger-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isthininteger","text":"isthininteger(x)\n\nReturn whether the inverval only contains a single integer.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinzero-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isthinzero","text":"isthinzero(x)\n\nReturn whether the interval only contains zero.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isweaklyless-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.isweaklyless","text":"isweaklyless(a, b)\n\nChecks if the interval a is weakly less than interval b.\n\nNote that this is not equivalent as saying every element of a is less than any element of b.\n\nImplement the less function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mag-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mag","text":"mag(a::Interval)\n\nMagnitude of an interval. Return NaN for empty intervals.\n\nImplement the mag function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mid-Tuple{IntervalBox}","page":"API","title":"IntervalArithmetic.mid","text":"mid(X::IntervalBox, α=0.5)\n\nReturn a vector of the mid of each interval composing the IntervalBox.\n\nSee mid(X::Interval, α=0.5) for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mid","text":"mid(a::Interval)\n\nFind the midpoint of the interval a.\n\nImplement the mid function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.midpoint_radius-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.midpoint_radius","text":"midpoint_radius(a::Interval)\n\nReturn the midpoint of an interval a together with its radius.\n\nFunction required by the IEEE Standard 1788-2015 in Section 10.5.9 for the set-based flavor.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mig-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mig","text":"mig(a::Interval)\n\nMignitude of an interval. Return NaN for empty intervals.\n\nImplement the mig function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{N}, Tuple{IntervalBox{N}, Int64}} where N","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::IntervalBox, n::Int)\n\nSplits x in n intervals in each dimension of the same diameter. These intervals are combined in all possible IntervalBox-es, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::Interval, n)\n\nSplit x in n intervals of the same diameter, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Any}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::IntervalBox, n)\n\nSplit x in n intervals in each dimension of the same diameter. These intervals are combined in all possible IntervalBox-es, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Tuple{Vararg{Int64, N}}}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::IntervalBox, ncuts::::NTuple{N,Int})\n\nSplits x[i] in ncuts[i] intervals . These intervals are combined in all possible IntervalBox-es, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.nai","text":"NaI not-an-interval: [NaN, NaN].\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.nthroot-Tuple{Interval{BigFloat}, Integer}","page":"API","title":"IntervalArithmetic.nthroot","text":"nthroot(a::Interval, n::Integer)\n\nCompute the real n-th root of Interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.numtype-Tuple{F} where F","page":"API","title":"IntervalArithmetic.numtype","text":"numtype(::T)\nnumtype(::Type{T})\n\nReturn the type T of the bounds of the interval.\n\nExample\n\njulia> IntervalArithmetic.numtype(interval(1, 2))\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.overlap-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.overlap","text":"overlap(a::Interval, b::Interval)\n\nImplement the overlap function according to the IEEE Standard 1788-2015 (Section 10.6.4 and Table 10.7).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.parse_num-Union{Tuple{T}, Tuple{S}, Tuple{Type{T}, AbstractString, RoundingMode{:Down}}} where {S<:Integer, T<:Rational{S}}","page":"API","title":"IntervalArithmetic.parse_num","text":"Same as parse(T, s, rounding_mode), but also accept string representing rational numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pow-Union{Tuple{T}, Tuple{Interval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.pow","text":"pow(x::Interval, n::Integer)\n\nA faster implementation of x^n, currently using power_by_squaring. pow(x, n) will usually return an interval that is slightly larger than that calculated by x^n, but is guaranteed to be a correct enclosure when using multiplication with correct rounding.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.precedes-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.precedes","text":"precedes(a, b)\n\nChecks if the interval a is to the left of interval b.\n\nImplement the precedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.promote_numtype","text":"promote_numtype(T, S)\n\nReturn the bound type used to construct intervals. The bound type is given by promote_type(T, S) if T or S is a Rational or an AbstractFloat; except when T is a Rational{R} and S is an AbstractIrrational (or vice-versa), in which case the bound type is given by Rational{promote_type(R, Int64)}. In all other cases, the bound type is given by promote_type(default_numtype(), T, S).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.radius-Tuple{Interval}","page":"API","title":"IntervalArithmetic.radius","text":"radius(a::Interval)\n\nReturn the radius of the interval a, such that a ⊆ m ± radius, where m = mid(a) is the midpoint.\n\nImplement the rad function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.round_expr-Tuple{Expr, RoundingMode}","page":"API","title":"IntervalArithmetic.round_expr","text":"round_expr(ex::Expr, rounding_mode::RoundingMode)\n\nTransforms a single expression by applying a rounding mode, e.g.\n\na + b into +(a, b, RoundDown)\nsin(a) into sin(a, RoundDown)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.scaled_mid-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.scaled_mid","text":"scaled_mid(a::Interval, α)\n\nFind an intermediate  point at a relative position α in the interval a instead.\n\nAssume 0 ≤ α ≤ 1.\n\nNote that scaled_mid(a, 0.5) does not equal mid(a) for unbounded set-based intervals.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.setformat","page":"API","title":"IntervalArithmetic.setformat","text":"setformat(format::Symbol; decorations::Bool, sigdigits::Int)\nsetformat()\n\nChange the format used by show to display intervals.\n\nInitially, the display options are format = :standard, decorations = false and sigdigits = 6.\n\nIf any of the three argument format, decorations and sigdigits is omitted, then their value is left unchanged.\n\nIf the three arguments are omitted, i.e. calling setformat(), then the values are reset to the default display options.\n\nPossible options:\n\nformat can be:\n:standard: [1, 2].\n:midpoint: display x::Interval in the form \"mid(x) ± radius(x)\".\n:full: display the entire bounds regardless of sigdigits.\nsigdigits: number (greater or equal to 1) of significant digits to display.\ndecorations: display the decorations or not.\n\nExample\n\njulia> x = interval(0.1, 0.3)  # Default display options\n[0.0999999, 0.300001]\n\njulia> setformat(:full)\nDisplay parameters:\n  - format: full\n  - decorations: true\n  - significant digits: 6\n\njulia> x\nInterval(0.09999999999999999, 0.30000000000000004)\n\njulia> setformat(:standard; sigdigits = 3)\nDisplay parameters:\n  - format: standard\n  - decorations: true\n  - significant digits: 3\n\njulia> x\n[0.0999, 0.301]\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.strictprecedes-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.strictprecedes","text":"strictprecedes(a, b)\n\nChecks if the interval a is strictly to the left of interval b.\n\nImplement the strictPrecedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.sup-Tuple{Interval}","page":"API","title":"IntervalArithmetic.sup","text":"sup(a::Interval)\n\nSupremum of an interval.\n\nImplement the sup function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.symmetric_box-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.symmetric_box","text":"symmetric_box(N, T)\n\nReturn the symmetric interval box of dimension N in the numeric type T, each side is Interval(-1, 1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.unsafe_scale-Union{Tuple{T}, Tuple{Interval{T}, T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.unsafe_scale","text":"unsafe_scale(a::Interval, α)\n\nMultiply an interval by a positive scalar. For efficiency, does not check that the constant is positive.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.zero_times_infinity-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.zero_times_infinity","text":"zero_times_infinity(::Flavor, ::Type{T})\n\nReturn the result of zero times positive infinity for the given flavor and number type T.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.@I_str-Tuple{Any}","page":"API","title":"IntervalArithmetic.@I_str","text":"I\"str\"\n\nCreate an interval according to the IEEE Standard 1788-2015. This is semantically equivalent to parse(DecoratedInterval{default_numtype()}, str) if the string contains the character _ which delimits the interval and its decoration; otherwise, it is semantically equivalent to parse(Interval{default_numtype()}, str).\n\nExamples\n\njulia> setformat(:full);\n\njulia> I\"[3, 4]\"\nInterval{Float64}(3.0, 4.0)\n\njulia> I\"0.1\"\nInterval{Float64}(0.09999999999999999, 0.1)\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@round-Tuple{Any, Any, Any}","page":"API","title":"IntervalArithmetic.@round","text":"@round(F, ex1, ex2)\n\nMacro for internal use that creates an interval of flavor F by rounding down ex1 and rounding up ex2. Each expression may consist of only a single operation that needs rounding, e.g. a.lo + b.lo or sin(a.lo). It also handles min(...) and max(...), where the arguments are each themselves single operations.\n\nThe macro uses the internal round_expr function to transform e.g. a + b into +(a, b, RoundDown).\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.Region","page":"API","title":"IntervalArithmetic.Region","text":"Region{T} = Union{Interval{T}, IntervalBox{T}}\n\n\n\n\n\n","category":"type"},{"location":"manual/construction/#Constructing-intervals","page":"Constructing intervals","title":"Constructing intervals","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Constructing an interval is the most basic operation in the library. The interval constructor is the standard way to create an interval. It accepts one or two values, and an optional bound type.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"using IntervalArithmetic\nsetformat(:full) # print the interval in full\ninterval(0.1) # interval(Float64, 0.1)\ninterval(0.1, 0.2) # interval(Float64, 0.1, 0.2)\ninterval(3.1f0) # interval(Float32, 3.1f0)\ninterval(π) # interval(Float64, π)\ninterval(BigFloat, π)\ninterval(Inf) # not valid since infinity is not part of an interval\ninterval(3, 2) # not valid since the lower bound is strictly greater than the upper bound","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The submodule IntervalArithmetic.Symbols exports the infix operator .. as an alias for interval.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"using IntervalArithmetic.Symbols\n0.1..0.2 # interval(0.1, 0.2)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The ± (\\pm<tab>) infix operator creates the interval from the midpoint and the radius.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"0 ± 1","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The various string formats are as follows:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"No string parameter or Empty string (\"[Empty]\") returns an empty interval.\nentire (\"[entire]\") and \"[,]\" string returns entireinterval\n\"[nai]\" returns Nai{Type}\n\"[m]\" returns Interval(m,m)\n\"[l, r]\" returns Interval(l, r)\n\"m?r\" returns Interval(m-r, m+r)\n\"m?ren\" returns Interval((m-r)en, (m+r)en)\n\"m?ru\" or \"m?rd\" returns Interval(m, m+r) or Interval(m-r, m) respectively\n\"m?\" returns Interval(m + 5 precision units, m - 5 precision units)\n\"m??\" returns Interval(-Inf, +Inf)\n\"m??u\" or \"m??d\" returns Interval(m, +Inf) or Interval(-Inf, m) respectively","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"warning: Warning\nMost real numbers cannot be exactly represented by floating-points. In such cases, the literal expression is rounded at parse time. To construct an interval enclosing the true real number, one must rely on the string constructor mentioned above.For instance, considerx = 0.1This appears to store the real number 110 in a variable x of type Float64. Yet,x > 1//10Hence, the floating-point 0.1 is (slightly) greater than the real number 110 since 110 cannot be represented exactly in binary floating-point arithmetic, at any precision. The true value must be approximated by a floating-point number with fixed precision – this procedure is called rounding.In particular, this implies that interval(0.1) does not contain the real number 110. A valid interval containing the real number 110 can be constructed byI\"0.1\"","category":"page"},{"location":"manual/usage/#Display-modes","page":"Usage","title":"Display modes","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"There are several useful output representations for intervals, some of which we have already touched on. The display is controlled globally by the setformat function, which has the following options, specified by keyword arguments (type ?setformat to get help at the REPL):","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"format: interval output format\n:standard: output of the form [1.09999, 1.30001], rounded to the current number of significant figures\n:full: output of the form Interval(1.0999999999999999, 1.3), as in the showfull function\n:midpoint: output in the midpoint-radius form, e.g. 1.2 ± 0.100001\nsigfigs: number of significant figures to show in standard mode\ndecorations (boolean): whether to show decorations or not","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"using IntervalArithmetic\nsetformat() # default values\na = interval(1.1, pi)\nsetformat(; sigdigits = 10)\na\nsetformat(:full)\na\nsetformat(:midpoint)\na\nsetformat(; sigdigits = 4)\na\nsetformat(:standard)\na","category":"page"},{"location":"manual/usage/#Arithmetic-operations","page":"Usage","title":"Arithmetic operations","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Basic arithmetic operations (+, -, *, /, ^) are defined for pairs of intervals in a standard way: the result is the smallest interval containing the result of operating with each element of each interval. More precisely, for two intervals X and Y and an operation bigcirc, we define the operation on the two intervals by","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X bigcirc Y =  x bigcirc y  x in X text and  y in Y ","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"For example,","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"using IntervalArithmetic\nsetformat(:full)\nX = interval(0, 1)\nY = interval(1, 2)\nX + Y","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Due to the above definition, subtraction of two intervals may give poor enclosures:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X - X","category":"page"},{"location":"manual/usage/#Elementary-functions","page":"Usage","title":"Elementary functions","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"The main elementary functions are implemented. The functions for Interval{Float64} internally use routines from the correctly-rounded CRlibm library where possible, i.e. for the following functions defined in that library:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"exp, expm1\nlog, log1p, log2, log10\nsin, cos, tan\nasin, acos, atan\nsinh, cosh","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Other functions that are implemented for Interval{Float64} internally convert to an Interval{BigFloat}, and then use routines from the MPFR library (BigFloat in Julia):","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"^\nexp2, exp10\natan, atanh","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Note, in particular, that in order to obtain correct rounding for the power function (^), intervals are converted to and from BigFloat; this implies a significant slow-down in this case.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"For example,","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X = interval(1)\nsin(X)\ncos(cosh(X))\nsetprecision(BigFloat, 53)\nY = big(X)\nsin(Y)\ncos(cosh(Y))\nsetprecision(BigFloat, 128)\nsin(Y)","category":"page"},{"location":"manual/usage/#Multi-dimensional-intervals","page":"Usage","title":"Multi-dimensional intervals","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Multi-dimensional (hyper-)boxes are implemented in the IntervalBox type. These represent Cartesian products of intervals, i.e. rectangles (in 2D), cuboids (in 3D), etc.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"IntervalBoxes are constructed from an array of Intervals; it is often convenient to use the .. notation:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"julia> using IntervalArithmetic\n\njulia> X = IntervalBox(1..3, 2..4)\n[1, 3] × [2, 4]\n\njulia> Y = IntervalBox(2.1..2.9, 3.1..4.9)\n[2.09999, 2.90001] × [3.09999, 4.90001]","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Several operations are defined on IntervalBoxes, for example:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"julia> X ∩ Y\n[2.09999, 2.90001] × [3.09999, 4]\n\njulia> X ⊆ Y\nfalse","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Given a multi-dimensional function taking several inputs, and interval box can be constructed as follows:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"julia> f(x, y) = (x + y, x - y)\nf (generic function with 1 method)\n\njulia> X = IntervalBox(1..1, 2..2)\n[1, 1] × [2, 2]\n\njulia> f(X...)\n([3, 3], [-1, -1])\n\njulia> IntervalBox(f(X...))\n[3, 3] × [-1, -1]","category":"page"},{"location":"#IntervalArithmetic.jl","page":"Home","title":"IntervalArithmetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntervalArithmetic.jl is a Julia package for validated numerics in Julia. All calculations are carried out using interval arithmetic where quantities are treated as intervals. The final result is a rigorous enclosure of the true value.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg # Julia v1.8 or above\nredirect_stderr(devnull) do # hide\nPkg.add(\"IntervalArithmetic\")\nend # hide","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use the IntervalArithmetic library in your publication, research, teaching, or other activities, please use the BibTeX template CITATION.bib.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MPFI.jl, a Julia wrapper around the MPFI C library, a multiple-precision interval arithmetic library based on MPFR\nIntervals.jl, an alternative implementation of basic interval functions by Invenia Technical Computing","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project began in 2014 during a masters' course in the postgraduate programs of Mathematics and Physics at the Universidad Nacional Autónoma de México. It was initially written in Python, then reinitiated in 2015 and rewritten in Julia. We thank the participants of the courses for their contribution, energy and ideas.","category":"page"},{"location":"#Support","page":"Home","title":"Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Luis Benet acknowledges support from Cátedra Marcos Moshinsky (2013).","category":"page"},{"location":"","page":"Home","title":"Home","text":"David P. Sanders acknowledges a sabbatical fellowship from CONACYT and thanks Alan Edelman and the Julia group at MIT for hosting his sabbatical visit.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"DocTestSetup = quote\n    using IntervalArithmetic\nend","category":"page"},{"location":"manual/decorations/#Decorations","page":"Decorations","title":"Decorations","text":"","category":"section"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"Decorations are flags, or labels, attached to intervals to indicate the status of a given interval as the result of evaluating a function on an initial interval. The combination of an interval X and a decoration d is called a decorated interval.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"The allowed decorations and their ordering are as follows: com > dac > def > trv > ill.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"Suppose that a decorated interval (X d) is the result of evaluating a function f, or the composition of a sequence of functions, on an initial decorated interval (X_0 d_0). The meaning of the resulting decoration d is as follows:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"com (\"common\"): X is a closed, bounded, nonempty subset of the domain of f; f is continuous on the interval X; and the resulting interval f(X) is bounded.\ndac (\"defined & continuous\"): X is a nonempty subset of mathrmDom(f), and f is continuous on X.\ndef (\"defined\"): X is a nonempty subset of mathrmDom(f), i.e. f is defined at each point of X.\ntrv (\"trivial\"): always true; gives no information\nill (\"ill-formed\"): Not an Interval (an error occurred), e.g. mathrmDom(f) = emptyset.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"An example will be given at the end of this section.","category":"page"},{"location":"manual/decorations/#Initialisation","page":"Decorations","title":"Initialisation","text":"","category":"section"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"The simplest way to create a DecoratedInterval is as follows:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> X = DecoratedInterval(3, 4)\n[3, 4]","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"By default, decorations are not displayed. The following turns on display of decorations:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> setformat(decorations=true)\nDisplay parameters:\n- format: standard\n- decorations: true\n- significant figures: 6\n\njulia> X\n[3, 4]_com","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"To parse string, for decorated interval add _dec at the end of the string otherwise decoration is determined using decoration function.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"If no decoration is explicitly specified when a DecoratedInterval is created, then it is initialised with a decoration according to its interval X:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"com: if X is nonempty and bounded;\ndac if X is unbounded;\ntrv if X is empty.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"An explicit decoration may be provided for advanced use:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> DecoratedInterval(3, 4, dac)\n[3, 4]_dac\n\njulia> DecoratedInterval(X, def)\n[3, 4]_def","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"Here, a new DecoratedInterval was created by extracting the interval from another one and appending a different decoration.","category":"page"},{"location":"manual/decorations/#Action-of-functions","page":"Decorations","title":"Action of functions","text":"","category":"section"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"A decoration is the combination of an interval together with the sequence of functions that it has passed through. Here are some examples:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> X1 = DecoratedInterval(0.5, 3)\n[0.5, 3]_com\n\njulia> sqrt(X1)\n[0.707106, 1.73206]_com","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"In this case, both input and output are \"common\" intervals, meaning that they are closed and bounded, and that the resulting function is continuous over the input interval, so that fixed-point theorems may be applied. Since sqrt(X1) ⊆ X1, we know that there must be a fixed point of the function inside the interval X1 (in this case, sqrt(1) == 1).","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> X2 = DecoratedInterval(3, ∞)\n[3, ∞]_dac\n\njulia> sqrt(X2)\n[1.73205, ∞]_dac","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"Since the intervals are unbounded here, the maximum decoration possible is dac.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> X3 = DecoratedInterval(-3, 4)\n[-3, 4]_com\n\njulia> sign(X3)\n[-1, 1]_def","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"The sign function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration is def.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> X4 = DecoratedInterval(-3.5, 4.1)\n[-3.5, 4.1]_com\n\njulia> sqrt(X4)\n[0, 2.02485]_trv","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"The negative part of X is discarded by the sqrt function, since its domain is [0,∞]. (This process of discarding parts of the input interval that are not in the domain is called \"loose evaluation\".) The fact that this occurred is, however, recorded by the resulting decoration, trv, indicating a loss of information: \"nothing is known\" about the relationship between the output interval and the input.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"In this case, we know why the decoration was reduced to trv. But if this were just a single step in a longer calculation, a resulting trv decoration shows only that something like this happened at some step. For example:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> X5 = DecoratedInterval(-3, 3)\n[-3, 3]_com\n\njulia> asin(sqrt(X5))\n[0, 1.5708]_trv\n\njulia> X6 = DecoratedInterval(0, 3)\n[0, 3]_com\n\njulia> asin(sqrt(X6))\n[0, 1.5708]_trv","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"In both cases, asin(sqrt(X)) gives a result with a trv decoration, but we do not know at which step this happened, unless we break down the function into its constituent parts:","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"julia> sqrt(X5)\n[0, 1.73206]_trv\n\njulia> sqrt(X6)\n[0, 1.73206]_com","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"This shows that loose evaluation occurred in different parts of the expression in the two different cases.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"In general, the trv decoration is thus used only to signal that \"something unexpected\" happened during the calculation. Often this is later used to split up the original interval into pieces and reevaluate the function on each piece to refine the information that is obtained about the function.","category":"page"},{"location":"manual/decorations/","page":"Decorations","title":"Decorations","text":"DocTestSetup = nothing","category":"page"}]
}

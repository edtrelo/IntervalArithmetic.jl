var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"DocTestSetup = quote\n    using IntervalArithmetic\nend","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nModule = [IntervalArithmetic]\nOrder = [:type, :macro, :function, :constant]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalArithmetic]\nOrder   = [:type, :macro, :function, :constant]","category":"page"},{"location":"api/#IntervalArithmetic.DECORATION","page":"API","title":"IntervalArithmetic.DECORATION","text":"DECORATION\n\nEnumeration constant for the types of interval decorations. The nomenclature follows Section 11.2 of the IEEE Standard 1788-2015:\n\ncom -> 4: non-empty, continuous and bounded (common)\ndac -> 3: non-empty and continuous (defined and continuous)\ndef -> 2: non-empty (defined)\ntrv -> 1: always true (trivial)\nill -> 0: not an interval (ill-formed)\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalArithmetic.DecoratedInterval","page":"API","title":"IntervalArithmetic.DecoratedInterval","text":"DecoratedInterval{T<:NumTypes}\n\nWraps an Interval together with a DECORATION, i.e. a flag that records the status of the interval when thought of as the result of a previously executed sequence of functions acting on an initial interval.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalArithmetic.Flavor","page":"API","title":"IntervalArithmetic.Flavor","text":"Flavor{F}\n\nSuper type of all interval flavors.\n\nA flavor defines (following the IEEE Std 1788-2015) how an interval behaves in edge cases. This mostly makes a difference when dealing with infinity and division by zero.\n\nCurrently only Flavor{:set_based} is supported.\n\n:set_based (default) : Elements of an interval are real number.   In particular, infinity is never part of an interval and is only used as a   shorthand.   For example, the interval (2..Inf) contain all real number greater than 2.   In particular, this means that (Inf..Inf) is an empty interval, and division   by a thin zero returns the empty interval.   The edge cases are       - x/(0..0) ≛ ∅       - (0..0)/(0..0) ≛ ∅       - (0..0)*(-Inf..Inf) ≛ 0       - Inf ∈ (0..Inf) == false   This flavor is described and required in part 2 of the IEEE Std 1799-2015.\n:cset (not implemented) : Elements of an interval are either real numbers   or ±Inf, applying standard rule for arithmetic with infinity.   The edge cases are       - x/(0..0) ≛ (-Inf..Inf)       - (0..0)/(0..0) ≛ (-Inf..Inf)       - (0..0)*(-Inf..Inf) ≛ (-Inf..Inf)       - Inf ∈ (0..Inf) == true\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalArithmetic.Interval","page":"API","title":"IntervalArithmetic.Interval","text":"Interval{T<:NumTypes} <: Real\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015.\n\nFields:\n\nlo::T\nhi::T\n\nConstructors compliant with the IEEE Standard 1788-2015:\n\ninterval\n..\n±\n@I_str\n\nwarning: Warning\nThe internal constructor unsafe_interval is not compliant with the IEEE Standard 1788-2015.\n\nSee also: interval, ±, .. and @I_str.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalArithmetic.IntervalBox","page":"API","title":"IntervalArithmetic.IntervalBox","text":"An IntervalBox is an N-dimensional rectangular box, given by a Cartesian product of a vector of N Intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalArithmetic.IntervalRounding","page":"API","title":"IntervalArithmetic.IntervalRounding","text":"IntervalRounding{T}\n\nInterval rounding trait type.\n\nAllowed rounding types are\n\n:tight: fast, tight (correct) rounding with errorfree arithmetic via           FastRounding.jl.\n:accurate: fast \"accurate\" rounding using prevfloat and nextfloat              (slightly wider than needed).\n:slow: tight (correct) rounding by changing rounding mode (slow).\n:none: no rounding (for speed comparisons; no enclosure is guaranteed).\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalArithmetic.@I_str-Tuple{Any}","page":"API","title":"IntervalArithmetic.@I_str","text":"I\"str\"\n\nCreate an interval according to the IEEE Standard 1788-2015. This is semantically equivalent to parse(DecoratedInterval{default_numtype()}, str) if the string contains the character _ which delimits the interval and its decoration; otherwise, it is semantically equivalent to parse(Interval{default_numtype()}, str).\n\nExamples\n\njulia> setformat(:full);\n\njulia> I\"[3, 4]\"\nInterval{Float64}(3.0, 4.0)\n\njulia> I\"0.1\"\nInterval{Float64}(0.09999999999999999, 0.1)\n\n\n\n\n\n","category":"macro"},{"location":"api/#IntervalArithmetic.@round-Tuple{Any, Any, Any}","page":"API","title":"IntervalArithmetic.@round","text":"@round(F, ex1, ex2)\n\nMacro for internal use that creates an interval of flavor F by rounding down ex1 and rounding up ex2. Each expression may consist of only a single operation that needs rounding, e.g. a.lo + b.lo or sin(a.lo). It also handles min(...) and max(...), where the arguments are each themselves single operations.\n\nThe macro uses the internal round_expr function to transform e.g. a + b into +(a, b, RoundDown).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:*","text":"*(a::Interval, b::Interval)\n*(a::Interval, b::Real)\n*(a::Real, b::Interval)\n\nImplement the mul function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of the multiplication is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:+","text":"+(a::Interval, b::Interval)\n+(a::Interval, b::Real)\n+(a::Real, b::Interval)\n\nImplement the add function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:-","text":"-(a::Interval)\n\nImplement the neg function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:-","text":"-(a::Interval, b::Interval)\n-(a::Interval, b::Real)\n-(a::Real, b::Interval)\n\nImplement the sub function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:/-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:/","text":"/(a::Interval, b::Interval)\n/(a::Interval, b::Real)\n/(a::Real, b::Interval)\n\nImplement the div function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of the division is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:^-Union{Tuple{F}, Tuple{F, F}} where F<:Interval","page":"API","title":"Base.:^","text":"^(a::Interval, b::Interval)\n^(a::Interval, b)\n\nImplement the pow function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.acot-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.acot","text":"acot(a::Interval)\n\nImplement the acot function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.acoth-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.acoth","text":"acoth(a::Interval)\n\nImplement the acoth function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.cot-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.cot","text":"cot(a::Interval)\n\nImplement the cot function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.coth-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.coth","text":"coth(a::Interval)\n\nImplement the coth function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.csc-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.csc","text":"csc(a::Interval)\n\nImplement the csc function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.csch-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.csch","text":"csch(a::Interval)\n\nImplement the csch function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.hypot-Tuple{Interval, Interval}","page":"API","title":"Base.Math.hypot","text":"hypot(x::Interval, n::Integer)\n\nDirect implemntation of hypot using intervals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.sec-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.sec","text":"sec(a::Interval)\n\nImplement the sec function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Math.sech-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.sech","text":"sech(a::Interval)\n\nImplement the sech function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.abs-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.abs","text":"abs(a::Interval)\n\nImplement the abs function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.acos-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.acos","text":"acos(a::Interval)\n\nImplement the acos function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.acosh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.acosh","text":"acosh(a::Interval)\n\nImplement the acosh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.asin-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.asin","text":"asin(a::Interval)\n\nImplement the asin function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.asinh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.asinh","text":"asinh(a::Interval)\n\nImplement the asinh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.atan-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atan","text":"atan(a::Interval)\n\nImplement the atan function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.atanh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atanh","text":"atanh(a::Interval)\n\nImplement the atanh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ceil-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.ceil","text":"ceil(a::Interval)\n\nImplement the ceil function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.cos-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.cos","text":"cos(a::Interval)\n\nImplement the cos function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.cosh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.cosh","text":"cosh(a::Interval)\n\nImplement the cosh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.floor-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.floor","text":"floor(a::Interval)\n\nImplement the floor function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.fma-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.fma","text":"fma(a::Interval, b::Interval, c::Interval)\n\nFused multiply-add.\n\nImplement the fma function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.hash-Tuple{Interval, UInt64}","page":"API","title":"Base.hash","text":"hash(x::Interval, h)\n\nCompute the integer hash code for an interval using the method for composite types used in AutoHashEquals.jl.\n\nNote that in IntervalArithmetic.jl, equality of intervals is given by ≛ rather than the == operator. The latter is reserved for the pointwise extension of equality to intervals and uses three-way logic by default.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Tuple{Real, Interval}","page":"API","title":"Base.in","text":"in(x, a)\n∈(x, a)\n\nChecks if the number x is a member of the interval a, treated as a set.\n\nImplement the isMember function of the IEEE Standard 1788-2015 (section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.intersect","page":"API","title":"Base.intersect","text":"intersect(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.intersect-Tuple{Union{Complex{<:Interval}, Interval}, Vararg{Union{Complex{<:Interval}, Interval}}}","page":"API","title":"Base.intersect","text":"intersect(a::Interval{T}...) where T\n\nReturn the n-ary intersection of its arguments.\n\nThis function is applicable to any number of input intervals, as in intersect(a1, a2, a3, a4) where ai is an interval. If your use case needs to splat the input, as in intersect(a...), consider reduce(intersect, a) instead, because you save the cost of splatting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.intersect-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"Base.intersect","text":"intersect(a, b)\n∩(a,b)\n\nReturns the intersection of the intervals a and b, considered as (extended) sets of real numbers. That is, the set that contains the points common in a and b.\n\nImplement the intersection function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.inv","text":"inv(a::Interval)\n\nImplement the recip function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of the division is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isdisjoint-Tuple{Interval, Interval}","page":"API","title":"Base.isdisjoint","text":"isdisjoint(a,b)\n\nChecks if all the points of the interval a are within the interior of interval b.\n\nImplement the disjoint function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.issubset-Tuple{Interval, Interval}","page":"API","title":"Base.issubset","text":"⊆(a,b)\n\nChecks if all the points of the interval a are within the interval b.\n\nTyped with \\subseteq<TAB>.\n\nImplement the subset function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.max-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.max","text":"max(a::Interval, b::Interval)\n\nImplement the max function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.min-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.min","text":"min(a::Interval, b::Interval)\n\nImplement the min function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parse-Union{Tuple{F}, Tuple{Type{F}, AbstractString}} where F<:Interval","page":"API","title":"Base.parse","text":"parse(Interval, s::AbstractString)\n\nCreate an interval according to the IEEE Standard 1788-2015. In contrast with constructors that do not use strings, this constructor guarantees that the returned interval tightly encloses the values described by the string, including numbers that have no exact float representation (e.g. 0.1).\n\nExamples of allowed string formats:\n\nI\"[1.33]\" or I\"1.33\": the interval containing 133.\nI\"[1.44, 2.78]\": the interval 144 278.\nI\"[empty]\": the empty interval.\nI\"[entire]\" or I\"[,]\": the interval -infty infty.\nI\"[3,]\": the interval 3 infty.\nI\"6.42?2\": the interval 64  644. The number after ? represents the   uncertainty in the last digit; by default this value is 0.5. The direction   of the uncertainty can be given by adding u or d at the end for the error   to only go up or down respectively (e.g. I\"4.5?5u\" represents 45 5).\nI\"6.42?2e2\": the interval 642 644.\nI\"3??u\": the interval 3 infty.\nI\"3??u\": the interval 3 infty.\nI\"3??\": the interval -infty infty.\n\nFor more details, see sections 9.7 and 12.11 of the IEEE Standard 1788-2015.\n\nExamples\n\njulia> setformat(:full);\n\njulia> parse(Interval{Float64}, \"[1, 2]\")\nInterval{Float64}(1.0, 2.0)\n\njulia> parse(Interval{Float64}, \"[1, 2]\")\nInterval{Float64}(1.0, 2.0)\n\njulia> parse(Interval{Float64}, \"[1,]\")\nInterval{Float64}(1.0, Inf)\n\njulia> parse(Interval{Float64}, \"[,]\")\nInterval{Float64}(-Inf, Inf)\n\njulia> parse(Interval{Float64}, \"6.42?2e2\")\nInterval{Float64}(640.0, 644.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}}, AbstractString}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.parse","text":"parse(DecoratedInterval, s::AbstractString)\n\nParse a string of the form \"[a, b]_dec\" as a DecoratedInterval with decoration dec. If the decoration is not specified, it is computed based on the parsed interval. If the input is an invalid string, a warning is printed and [NaI] is returned. The parser is case unsensitive.\n\nExamples\n\njulia> setformat(:full);\n\njulia> parse(DecoratedInterval{Float64}, \"[1, 2]\")\n[1, 2]_com\n\njulia> parse(DecoratedInterval{Float64}, \"[1, 2]_def\")\n[1, 2]_def\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.round-Tuple{Interval}","page":"API","title":"Base.round","text":"round(a::Interval[, RoundingMode])\n\nReturn the interval with limits rounded to an integer.\n\nImplement the functions roundTiesToEven and roundTiesToAway of the IEEE Standard 1788-2015.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.setdiff","text":"setdiff(x::Interval, y::Interval)\n\nCalculate the set difference x ∖ y, i.e. the set of values that are inside the interval x but not inside y.\n\nReturns an array of intervals. The array may:\n\nbe empty if x ⊆ y;\ncontain a single interval, if y overlaps x\ncontain two intervals, if y is strictly contained within x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, IntervalBox{N, T}}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"Base.setdiff","text":"setdiff(A::IntervalBox{N,T}, B::IntervalBox{N,T})\n\nReturns a vector of IntervalBoxes that are in the set difference A ∖ B, i.e. the set of x that are in A but not in B.\n\nAlgorithm: Start from the total overlap (in all directions); expand each direction in turn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sign-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sign","text":"sign(a::Interval)\n\nImplement the sign function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.signbit-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.signbit","text":"signbit(a::Interval)\n\nReturn an interval containing 1 if any element in a is negative and containing 0 if any element in a is positive. An empty interval is returned if a is empty.\n\nExamples\n\njulia> setformat(:full);\n\njulia> signbit(interval(-4))\nInterval{Float64}(1.0, 1.0)\n\njulia> signbit(interval(5))\nInterval{Float64}(0.0, 0.0)\n\njulia> signbit(interval(-4,5))\nInterval{Float64}(0.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sin-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sin","text":"sin(a::Interval)\n\nImplement the sin function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sinh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sinh","text":"sinh(a::Interval)\n\nImplement the sinh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sqrt-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sqrt","text":"sqrt(a::Interval)\n\nSquare root of an interval.\n\nImplement the sqrt function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.tan-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.tan","text":"tan(a::Interval)\n\nImplement the tan function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.tanh-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.tanh","text":"tanh(a::Interval)\n\nImplement the tanh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.trunc-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.trunc","text":"trunc(a::Interval)\n\nImplement the trunc function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union","page":"API","title":"Base.union","text":"union(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.union-Tuple{Union{Complex{<:Interval}, Interval}, Union{Complex{<:Interval}, Interval}}","page":"API","title":"Base.union","text":"union(a, b)\n∪(a,b)\n\nReturn the union (convex hull) of the intervals a and b; it is equivalent to hull(a,b).\n\nImplement the converxHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.zero-Union{Tuple{Type{IntervalBox{N, T}}}, Tuple{T}, Tuple{N}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"Base.zero","text":"zero(IntervalBox{N, T})\n\nReturn the zero interval box of dimension N in the numeric type T.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.:±-Tuple{Any, Any}","page":"API","title":"IntervalArithmetic.:±","text":"±(m, r)\nm ± r\n\nCreate the interval m - r m + r according to the IEEE Standard 1788-2015. Despite using the midpoint-radius notation, the returned interval is still an Interval represented by its bounds.\n\nwarning: Warning\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, use the string macro @I_str to ensure tight enclosure around the typed numbers.\n\nSee also: interval, .. and @I_str.\n\nExamples\n\njulia> setformat(:full);\n\njulia> 0 ± π\nInterval{Float64}(-3.1415926535897936, 3.1415926535897936)\n\njulia> 0//1 ± π\nInterval{Rational{Int64}}(-85563208//27235615, 85563208//27235615)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.:≛-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.:≛","text":"≛(a::Interval, b::Interval)\n\nChecks if the intervals a and b are identical.\n\nTyped as \\starequal<TAB>.\n\nImplement the equal function of the IEEE Standard 1788-2015  (Table 9.3).\n\nThe more common == operator is reserved for flavor dependent pointwise equality.\n\nIn most case this is equivalent to the built-in ===.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.:≛-Tuple{Interval, Real}","page":"API","title":"IntervalArithmetic.:≛","text":"≛(a::Interval, x::Real)\n\nCheck if the interval a contains exactly (and only) the number x.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.:⊂-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.:⊂","text":"⊂(a,b)\n\nChecks if a is a strict subset of interval b.\n\nTyped with \\subset<TAB>.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic._parse-Union{Tuple{T}, Tuple{Type{Interval{T}}, AbstractString}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._parse","text":"_parse(::Type{Interval{T}}, s::AbstractString) where T\n\ntries to parse the string s to an interval of type Interval{T} and throws an argument error if an invalid string is given.\n\nOutput\n\nthe parsed interval\na flag isnotcom, which is set to true if the input interval is not com and to false otherwise. This is used to distinguish the case when an interval is supposed to be unbounded (e.g. input \"[3, infinity]\") or becomes unbounded because of overflow (e.g. the input \"[3, 1e400]\", which is parse to[3, ∞]when usingFloat64`).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic._setdiff-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._setdiff","text":"_setdiff(x::Interval{T}, y::Interval{T})\n\nComputes the set difference x\\y and always returns a tuple of two intervals. If the set difference is only one interval or is empty, then the returned tuple contains 1 or 2 empty intervals.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.atomic-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.atomic","text":"atomic(T<:Union{Rational,AbstractFloat}, a)\n\nCreate an interval according to the IEEE Standard 1788-2015. The returned Interval{T} always contains the value a but its construction depends on its type. If a is an AbstractString, then the interval is constructed by calling parse. If a is an AbstractFloat, the interval is widen to two eps to be sure to contain the number that was typed in. In all other cases, this is semantically equivalent to interval(T, a).\n\nExamples\n\njulia> setformat(:full);\n\njulia> IntervalArithmetic.atomic(Float64, 0.1)\nInterval{Float64}(0.09999999999999999, 0.10000000000000002)\n\njulia> IntervalArithmetic.atomic(Float64, 0.1)\nInterval{Float64}(0.29999999999999993, 0.30000000000000004)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.bigequiv-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bigequiv","text":"bigequiv(x::Interval)\nbigequiv(x::Union{Rational,AbstractFloat})\n\nCreate a BigFloat equivalent with the same underlying precision as x.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.bisect","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(X::IntervalBox, i::Integer, α=0.49609375)\n\nBisect the IntervalBox in side number i.\n\n\n\n\n\n","category":"function"},{"location":"api/#IntervalArithmetic.bisect-2","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(X::IntervalBox, α=0.49609375)\n\nBisect the IntervalBox X at position α ∈ [0,1] along its longest side.\n\n\n\n\n\n","category":"function"},{"location":"api/#IntervalArithmetic.bisect-Union{Tuple{Interval{T}}, Tuple{T}, Tuple{Interval{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(X::Interval, α=0.49609375)\n\nSplit the interval X at position α; α=0.5 corresponds to the midpoint. Returns a tuple of the new intervals.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.bounds-Tuple{Interval}","page":"API","title":"IntervalArithmetic.bounds","text":"bounds(a::Interval)\n\nBounds of an interval as a tuple. This is semantically equivalent to (a.lo, sup(a)). In particular, this function does not normalize the lower bound.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.cancelminus","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"api/#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(a, b)\n\nReturn the unique interval c such that b + c = a.\n\nImplement the cancelMinus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.cancelplus","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"api/#IntervalArithmetic.cancelplus-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(a, b)\n\nReturn the unique interval c such that b - c = a.\n\nEquivalent to cancelminus(a, -b).\n\nImplement the cancelPlus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.default_numtype-Tuple{}","page":"API","title":"IntervalArithmetic.default_numtype","text":"default_numtype()\n\nReturn the default bound type used in promote_numtype. By default, default_numtype() is set to Float64. It can be modified by redefining the function, however it should be set to a concrete subtype of Rational or AbstractFloat.\n\nExamples\n\njulia> IntervalArithmetic.default_numtype()\nFloat64\n\njulia> typeof(interval(1, 2))\nInterval{Float64}\n\njulia> typeof(interval(1, big(2)))\nInterval{BigFloat}\n\njulia> IntervalArithmetic.default_numtype() = Float32\n\njulia> typeof(interval(1, 2))\nInterval{Float32}\n\njulia> typeof(interval(1, big(2)))\nInterval{BigFloat}\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.diam","text":"diam(a::Interval)\n\nReturn the diameter (length) of the interval a.\n\nImplement the wid function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.div_by_thin_zero-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.div_by_thin_zero","text":"div_by_thin_zero(::Flavor, x::Interval)\n\nDivide x by the interval containing only 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.emptyinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.emptyinterval","text":"emptyinterval\n\nemptyintervals are represented as the interval [∞, -∞]; note that this interval is an exception to the fact that the lower bound is larger than the upper one.\n\nNote that if the type of the returned interval can not be inferred from the argument given, the default interval bound type is used.\n\nImplement the empty function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.entireinterval-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.entireinterval","text":"entireinterval\n\nRR represent the entire real line [-Inf, Inf].\n\nDepending on the flavor, -Inf and Inf may or may not be considerd inside this interval.\n\nNote that if the type of the returned interval can not be inferred from the argument given, the default interval flavor will be used. See the documentation of Interval for more information about the default interval falvor.\n\nImplement the entire function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.extended_div","text":"extended_div(a::Interval, b::Interval)\n\nTwo-output division.\n\nImplement the mulRevToPair function of the IEEE Standard 1788-2015 (Section 10.5.5).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.find_quadrants","text":"find_quadrants(x)\n\nFinds the quadrant(s) corresponding to a given floating-point number. The quadrants are labelled as 0 for x ∈ [0, π/2], etc. A tuple of two quadrants is returned. The minimum or maximum must then be chosen appropriately.\n\nThis is a rather indirect way to determine if π/2 and 3π/2 are contained in the interval; cf. the formula for sine of an interval in Tucker, Validated Numerics.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.hull","page":"API","title":"IntervalArithmetic.hull","text":"hull(xx, yy)\n\nDecorated interval extension; the result is decorated as trv, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).\n\n\n\n\n\n","category":"function"},{"location":"api/#IntervalArithmetic.hull-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Interval{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.hull","text":"hull(a, b)\n\nReturn the \"interval hull\" of the intervals a and b, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of a and b.\n\nImplement the converxHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.inf-Tuple{Interval}","page":"API","title":"IntervalArithmetic.inf","text":"inf(a::Interval)\n\nInfimum of an interval. For a zero AbstractFloat lower bound, a negative zero is returned.\n\nImplement the inf function of the IEEE Standard 1788-2015 (Table 9.2 and Section 12.12.8).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.interval","text":"interval([T<:Union{Rational,AbstractFloat}=default_numtype()], a, b)\n\nCreate the interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then an Interval{T} is constructed, otherwise a warning is printed and the empty interval is returned.\n\nwarning: Warning\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, use the string macro @I_str to ensure tight enclosure around the typed numbers.\n\nSee also: ±, .. and @I_str.\n\nExamples\n\njulia> setformat(:full);\n\njulia> interval(1//1, π)\nInterval{Rational{Int64}}(1//1, 85563208//27235615)\n\njulia> interval(Rational{Int32}, 1//1, π)\nInterval{Rational{Int32}}(1//1, 85563208//27235615)\n\njulia> interval(1, π)\nInterval{Float64}(1.0, 3.1415926535897936)\n\njulia> interval(BigFloat, 1, π)\nInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.is_valid_interval-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}, Any, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.is_valid_interval","text":"is_valid_interval(a, b)\n\nCheck if (a, b) constitute a valid interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isatomic-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isatomic","text":"isatomic(x::Interval)\n\nCheck whether an interval x is atomic, i.e. is unable to be split. This occurs when the interval is empty, or when the upper bound equals the lower bound or the bounds are consecutive floating point numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.iscommon-Tuple{Interval}","page":"API","title":"IntervalArithmetic.iscommon","text":"iscommon(x)\n\nChecks if x is a common interval, i.e. a non-empty, bounded, real interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isinterior-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.isinterior","text":"isinterior(a,b)\n\nChecks if all the points of the interval a are within the interior of interval b.\n\nImplement the interior function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isstrictless-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.isstrictless","text":"isstrictless(a, b)\n\nChecks if the interval a is strictly less than interval b, which is true if inf(a) < inf(b) and sup(a) < sup(b).\n\nFor variants in the definition of \"strictly less than\" for intervals see strictprecedes and <.\n\nImplement the strictLess function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isthin-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x)\n\nChecks if x is the set consisting of a single exactly representable float. Any float which is not exactly representable does not yield a thin interval. Corresponds to isSingleton of the standard.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isthininteger-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isthininteger","text":"isthininteger(x)\n\nReturn whether the inverval only contains a single integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isthinzero-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isthinzero","text":"isthinzero(x)\n\nReturn whether the interval only contains zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.isweaklyless-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.isweaklyless","text":"isweaklyless(a, b)\n\nChecks if the interval a is weakly less than interval b.\n\nNote that this is not equivalent as saying every element of a is less than any element of b.\n\nImplement the less function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mag-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mag","text":"mag(a::Interval)\n\nMagnitude of an interval. Return NaN for empty intervals.\n\nImplement the mag function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mid-Tuple{IntervalBox}","page":"API","title":"IntervalArithmetic.mid","text":"mid(X::IntervalBox, α=0.5)\n\nReturn a vector of the mid of each interval composing the IntervalBox.\n\nSee mid(X::Interval, α=0.5) for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mid","text":"mid(a::Interval)\n\nFind the midpoint of the interval a.\n\nImplement the mid function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.midpoint_radius-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.midpoint_radius","text":"midpoint_radius(a::Interval)\n\nReturn the midpoint of an interval a together with its radius.\n\nFunction required by the IEEE Standard 1788-2015 in Section 10.5.9 for the set-based flavor.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mig-Union{Tuple{Interval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mig","text":"mig(a::Interval)\n\nMignitude of an interval. Return NaN for empty intervals.\n\nImplement the mig function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mince-Union{Tuple{N}, Tuple{IntervalBox{N}, Int64}} where N","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::IntervalBox, n::Int)\n\nSplits x in n intervals in each dimension of the same diameter. These intervals are combined in all possible IntervalBox-es, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::Interval, n)\n\nSplit x in n intervals of the same diameter, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Any}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::IntervalBox, n)\n\nSplit x in n intervals in each dimension of the same diameter. These intervals are combined in all possible IntervalBox-es, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N, T}, Tuple{Vararg{Int64, N}}}} where {N, T<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x::IntervalBox, ncuts::::NTuple{N,Int})\n\nSplits x[i] in ncuts[i] intervals . These intervals are combined in all possible IntervalBox-es, which are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.nai","text":"NaI not-an-interval: [NaN, NaN].\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.nthroot-Tuple{Interval{BigFloat}, Integer}","page":"API","title":"IntervalArithmetic.nthroot","text":"nthroot(a::Interval, n::Integer)\n\nCompute the real n-th root of Interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.numtype-Tuple{F} where F","page":"API","title":"IntervalArithmetic.numtype","text":"numtype(::T)\nnumtype(::Type{T})\n\nReturn the type T of the bounds of the interval.\n\nExample\n\njulia> IntervalArithmetic.numtype(interval(1, 2))\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.overlap-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.overlap","text":"overlap(a::Interval, b::Interval)\n\nImplement the overlap function according to the IEEE Standard 1788-2015 (Section 10.6.4 and Table 10.7).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.parse_num-Union{Tuple{T}, Tuple{S}, Tuple{Type{T}, AbstractString, RoundingMode{:Down}}} where {S<:Integer, T<:Rational{S}}","page":"API","title":"IntervalArithmetic.parse_num","text":"Same as parse(T, s, rounding_mode), but also accept string representing rational numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.pow-Union{Tuple{T}, Tuple{Interval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.pow","text":"pow(x::Interval, n::Integer)\n\nA faster implementation of x^n, currently using power_by_squaring. pow(x, n) will usually return an interval that is slightly larger than that calculated by x^n, but is guaranteed to be a correct enclosure when using multiplication with correct rounding.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.precedes-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.precedes","text":"precedes(a, b)\n\nChecks if the interval a is to the left of interval b.\n\nImplement the precedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.promote_numtype","text":"promote_numtype(T, S)\n\nReturn the bound type used to construct intervals. The bound type is given by promote_type(T, S) if T or S is a Rational or an AbstractFloat; except when T is a Rational{R} and S is an AbstractIrrational (or vice-versa), in which case the bound type is given by Rational{promote_type(R, Int64)}. In all other cases, the bound type is given by promote_type(default_numtype(), T, S).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.radius-Tuple{Interval}","page":"API","title":"IntervalArithmetic.radius","text":"radius(a::Interval)\n\nReturn the radius of the interval a, such that a ⊆ m ± radius, where m = mid(a) is the midpoint.\n\nImplement the rad function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.round_expr-Tuple{Expr, RoundingMode}","page":"API","title":"IntervalArithmetic.round_expr","text":"round_expr(ex::Expr, rounding_mode::RoundingMode)\n\nTransforms a single expression by applying a rounding mode, e.g.\n\na + b into +(a, b, RoundDown)\nsin(a) into sin(a, RoundDown)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.scaled_mid-Union{Tuple{T}, Tuple{Interval{T}, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.scaled_mid","text":"scaled_mid(a::Interval, α)\n\nFind an intermediate  point at a relative position α in the interval a instead.\n\nAssume 0 ≤ α ≤ 1.\n\nNote that scaled_mid(a, 0.5) does not equal mid(a) for unbounded set-based intervals.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.setformat","page":"API","title":"IntervalArithmetic.setformat","text":"setformat(format::Symbol; decorations::Bool, sigdigits::Int)\nsetformat()\n\nChange the format used by show to display intervals.\n\nInitially, the display options are format = :standard, decorations = false and sigdigits = 6.\n\nIf any of the three argument format, decorations and sigdigits is omitted, then their value is left unchanged.\n\nIf the three arguments are omitted, i.e. calling setformat(), then the values are reset to the default display options.\n\nPossible options:\n\nformat can be:\n:standard: [1, 2].\n:midpoint: display x::Interval in the form \"mid(x) ± radius(x)\".\n:full: display the entire bounds regardless of sigdigits.\nsigdigits: number (greater or equal to 1) of significant digits to display.\ndecorations: display the decorations or not.\n\nExample\n\njulia> x = interval(0.1, 0.3)  # Default display options\n[0.0999999, 0.300001]\n\njulia> setformat(:full)\nDisplay parameters:\n  - format: full\n  - decorations: true\n  - significant digits: 6\n\njulia> x\nInterval(0.09999999999999999, 0.30000000000000004)\n\njulia> setformat(:standard; sigdigits = 3)\nDisplay parameters:\n  - format: standard\n  - decorations: true\n  - significant digits: 3\n\njulia> x\n[0.0999, 0.301]\n\n\n\n\n\n","category":"function"},{"location":"api/#IntervalArithmetic.strictprecedes-Tuple{Interval, Interval}","page":"API","title":"IntervalArithmetic.strictprecedes","text":"strictprecedes(a, b)\n\nChecks if the interval a is strictly to the left of interval b.\n\nImplement the strictPrecedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.sup-Tuple{Interval}","page":"API","title":"IntervalArithmetic.sup","text":"sup(a::Interval)\n\nSupremum of an interval.\n\nImplement the sup function of the IEEE Standard 1788-2015 (Table 9.2).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.symmetric_box-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.symmetric_box","text":"symmetric_box(N, T)\n\nReturn the symmetric interval box of dimension N in the numeric type T, each side is Interval(-1, 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.unsafe_scale-Union{Tuple{T}, Tuple{T, Interval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.unsafe_scale","text":"unsafe_scale(α, a::Interval)\n\nMultiply an interval by a positive scalar. For efficiency, does not check that the constant is positive.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.zero_times_infinity-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.zero_times_infinity","text":"zero_times_infinity(::Flavor, ::Type{T})\n\nReturn the result of zero times positive infinity for the given flavor and number type T.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalArithmetic.Region","page":"API","title":"IntervalArithmetic.Region","text":"Region{T} = Union{Interval{T}, IntervalBox{T}}\n\n\n\n\n\n","category":"type"},{"location":"intro/#Introduction-to-Interval-Arithmetic","page":"Interval Arithmetic","title":"Introduction to Interval Arithmetic","text":"","category":"section"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"The basic idea in Interval Arithmetic is to calculate with entire sets of real numbers, of which the simplest type are closed intervals ab = x in mathbbR a le x le b .","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"We define arithmetic operations and functions to act on intervals in such a way that the result of the calculation is a new interval that is guaranteed to contain the true range of the function.","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"For example, for monotone functions like exp, we define","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"exp([a, b]) := [exp(a), exp(b)]","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"For non-monotone functions, like the squaring function, it is more complicated:","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"[a, b]^2 := [a^2, b^2]  if 0 < a < b\n          = [0, max(a^2, b^2)]  if a < 0 < b\n          = [b^2, a^2] if a < b < 0","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"We also have to round the lower endpoint down and the upper endpoint up to get guaranteed containment of the true result, since we are using floating-point arithmetic.","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"For more information on how different functions behave in Interval Arithmetic, refer to Interval Arithmetic.","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"Once we have done this for basic functions, we can define a complicated Julia function like","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"f(x) = sin(3x^2 - 2 cos(1/x))","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"and feed an interval in. Since at each step of the process, the result is an interval that is guaranteed to contain the range, the whole function has the same property.","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"For example,","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"julia> using IntervalArithmetic\n\njulia> f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia> X = 3..4\n[3, 4]\n\njulia> f(X)\n[7, 14]","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"Since f(X) does not contain 0, the true range of the function f over the set X is guaranteed not to contain 0, and hence we have","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"Theorem: The function f has no root in the interval 34.","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"This theorem has been obtained using just floating-point calculations!","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"Further, we can even extend this to semi-infinite intervals:","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"julia> f(3..∞)\n[7, ∞]","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"Thus we have excluded the entire domain [3, ∞) from possibly containing roots of f.","category":"page"},{"location":"intro/","page":"Interval Arithmetic","title":"Interval Arithmetic","text":"To move beyond just excluding regions and to actually guaranteeing existence and uniqueness for smooth functions, we use an interval version of the Newton method, which is described a bit here.","category":"page"},{"location":"rounding/#Why-is-rounding-necessary?","page":"Rounding","title":"Why is rounding necessary?","text":"","category":"section"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"What happens when we write the following Julia code?","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> x = 0.1\n0.1","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"This appears to store the value 0.1 in a variable x of type Float64. In fact, however, it stores a slightly different number, since 0.1 cannot be represented exactly in binary floating point arithmetic, at any precision.","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"The true value that is actually stored in the variable can be conveniently determined in Julia using arbitrary-precision arithmetic with BigFloats:","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> big(0.1)\n0.1000000000000000055511151231257827021181583404541015625","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"So, in fact, the Julia float 0.1 refers to a real number that is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode (RoundNearest); i.e., the nearest representable floating-point number to 0.1 is used.","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"[Recall that to get a BigFloat that is as close as possible to the true 0.1, you can use a special string macro:","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> big\"0.1\"\n0.1000000000000000000000000000000000000000000000000000000000000000000000000000002","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"]","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"Suppose that we create a thin interval, containing just the floating-point number 0.1:","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> using IntervalArithmetic\n\njulia> II = Interval(0.1)\n[0.1, 0.100001]\n\njulia> showfull(II)\nInterval(0.1, 0.1)","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"It looks like II contains (the true) 0.1, but from the above discussion we see that it does not. In order to contain 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"This rounding is handled by the @interval  macro, which generates correctly-rounded intervals:","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> a = @interval(0.1)\n[0.0999999, 0.100001]\n","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"The true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> f(x) = 2x + 0.2\nf (generic function with 1 method)\n","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"then we can apply the function f to the interval a to obtain","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> f(a)\n[0.399999, 0.400001]\n\njulia> showfull(f(a))\nInterval(0.39999999999999997, 0.4)","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"The result correctly contains the true 0.4.","category":"page"},{"location":"rounding/#More-detail:-the-internal-representation","page":"Rounding","title":"More detail: the internal representation","text":"","category":"section"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"Let's look at the internal representation of the Float64 number 0.1:","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"julia> bitstring(0.1)\n\"0011111110111001100110011001100110011001100110011001100110011010\"","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"The last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"0.000110011001100110011001100110011001100...","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"We see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits 1100. It is thus impossible to represent the decimal 0.1 in binary, with any precision.","category":"page"},{"location":"rounding/","page":"Rounding","title":"Rounding","text":"The true value must be approximated by a floating-point number with fixed precision – this procedure is called rounding. For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.","category":"page"},{"location":"usage/#Basic-usage","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The basic elements of the package are intervals, i.e. sets of real numbers (possibly including pm infty) of the form","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"a b =  a le x le b  subseteq mathbbR","category":"page"},{"location":"usage/#Creating-intervals","page":"Basic usage","title":"Creating intervals","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Intervals are created using the @interval macro, which takes one or two expressions:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> using IntervalArithmetic\n\njulia> a = @interval(1)\n[1, 1]\n\njulia> typeof(ans)\nInterval{Float64}\n\njulia> b = @interval(1, 2)\n[1, 2]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The objects returned are of the parameterized type Interval, the basic object in the package. By default, Interval objects contain Float64s, but the library also allows using other types such as Rationals and BigFloats; for example:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @biginterval(1, 2)\n[1, 2]₂₅₆\n\njulia> showfull(ans)\nInterval(1.0, 2.0)","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The constructor of the Interval type may be used directly, but this is generally not recommended, for the following reason:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia> b = @interval(0.1, 0.3)\n[0.0999999, 0.300001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"What is going on here?","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Due to the way floating-point arithmetic works, the interval a created directly by the constructor turns out to contain neither the true real number 0.1, nor 0.3, since the floating point number associated to 0.1 is actually rounded up, whereas the one associated to 0.3 is rounded down. The @interval macro, however, uses directed rounding to guarantee that the true 0.1 and 0.3 are included in the result.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Behind the scenes, the [@interval(@ref)] macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled by the convert function.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"This allows us to write, for example","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval sin(0.1) + cos(0.2)\n[1.07989, 1.0799]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"which is equivalent to","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> sin(@interval(0.1)) + cos(@interval(0.2))\n[1.07989, 1.0799]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"This can be used together with user-defined functions:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> f(x) = 2x\nf (generic function with 1 method)\n\njulia> f(@interval(0.1))\n[0.199999, 0.200001]\n\njulia> @interval f(0.1)\n[0.199999, 0.200001]","category":"page"},{"location":"usage/#\\pi","page":"Basic usage","title":"\\pi","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"You can create correctly-rounded intervals containing \\pi:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval(pi)\n[3.14159, 3.1416]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"and embed it in expressions:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval(3*pi/2 + 1)\n[5.71238, 5.71239]\n\njulia> @interval 3π/2 + 1\n[5.71238, 5.71239]","category":"page"},{"location":"usage/#Constructing-intervals","page":"Basic usage","title":"Constructing intervals","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Intervals may be constructed using rationals:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval(1//10)\n[0.0999999, 0.100001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Real literals are handled by internally converting them to rationals (using the Julia function rationalize). This gives a result that contains the computer's \"best guess\" for the real number the user \"had in mind\":","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval(0.1)\n[0.0999999, 0.100001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"If you instead know which exactly-representable floating-point number a you need and really want to make a thin interval, i.e., an interval of the form [a, a], containing precisely one float, then you can use the Interval constructor directly:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> a = Interval(0.1)\n[0.1, 0.100001]\n\njulia> showfull(a)\nInterval(0.1, 0.1)","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Here, the showfull function shows the internal representation of the interval, in a reproducible form that may be copied and pasted directly. It uses Julia's internal function (which, in turn, uses the so-called Grisu algorithm) to show exactly as many digits are required to give an unambiguous floating-point number.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Strings may be used inside @interval:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval \"0.1\"*2\n[0.199999, 0.200001]\n\njulia> @biginterval \"0.1\"*2\n[0.199999, 0.200001]₂₅₆\n\njulia> showfull(ans)\nInterval(0.1999999999999999999999999999999999999999999999999999999999999999999999999999983, 0.2000000000000000000000000000000000000000000000000000000000000000000000000000004)\n","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Strings in the form of intervals may also be used:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval \"[1.2, 3.4]\"\n[1.19999, 3.40001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Intervals can be created from variables:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> a = 3.6\n3.6\n\njulia> b = @interval(a)\n[3.59999, 3.60001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The upper and lower bounds of the interval may be accessed using the fields lo and hi:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> b.lo\n3.5999999999999996\n\njulia> b.hi\n3.6","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The diameter (length) of an interval is obtained using diam(b); for numbers that cannot be represented exactly in base 2 (i.e., whose binary expansion is infinite or exceeds the current precision),  the diameter of intervals created by @interval with a single argument corresponds to the local machine epsilon (eps) in the :narrow interval-rounding mode:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> diam(b)\n4.440892098500626e-16\n\njulia> eps(b.lo)\n4.440892098500626e-16","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"You can use additional syntax for creating intervals more easily. The for example, the .. operator is equivalent to using the macro:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> 0.1..0.3\n[0.0999999, 0.300001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"and the @I_str string macro:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> I\"3.1\"\n[3.09999, 3.10001]\n\njulia> I\"[3.1, 3.2]\"\n[3.09999, 3.20001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"You can also use the ± operator:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> 1.5 ± 0.1\n[1.39999, 1.60001]","category":"page"},{"location":"usage/#Arithmetic","page":"Basic usage","title":"Arithmetic","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Basic arithmetic operations (+, -, *, /, ^) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals X and Y and an operation \\bigcirc, we define the operation on the two intervals by","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"X bigcirc Y =  x bigcirc y x in X text and  y in Y ","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Again, directed rounding is used if necessary.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"For example:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> a = @interval(0.1, 0.3)\n[0.0999999, 0.300001]\n\njulia> b = @interval(0.3, 0.6)\n[0.299999, 0.600001]\n\njulia> a + b\n[0.399999, 0.900001]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"However, subtraction of two intervals gives an initially unexpected result, due to the above definition:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> a = @interval(0, 1)\n[0, 1]\n\njulia> a - a\n[-1, 1]","category":"page"},{"location":"usage/#Changing-the-precision","page":"Basic usage","title":"Changing the precision","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"By default, the @interval macro creates intervals of Float64s. This may be changed globally using the setprecision function:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> @interval 3π/2 + 1\n[5.71238, 5.71239]\n\njulia> showfull(ans)\nInterval(5.71238898038469, 5.712388980384691)\n\njulia> setprecision(Interval, 256)\n256\n\njulia> @interval 3π/2 + 1\n[5.71238, 5.71239]₂₅₆\n\njulia> showfull(ans)\nInterval(5.712388980384689857693965074919254326295754099062658731462416888461724609429262, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401)","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The subscript 256 at the end denotes the precision.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"To change back to Float64s, use","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> setprecision(Interval, Float64)\nFloat64\n\njulia> @interval(pi)\n[3.14159, 3.1416]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"To check which mode is currently set, use","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> precision(Interval)\n(Float64, 256)","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The result is a tuple of the type (currently Float64 or BigFloat) and the current BigFloat precision.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Note that the BigFloat precision is set internally by setprecision(Interval). You should not use setprecision(BigFloat) directly,   since the package carries out additional steps to ensure internal consistency of operations involving π, in particular trigonometric functions.","category":"page"},{"location":"usage/#Elementary-functions","page":"Basic usage","title":"Elementary functions","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The main elementary functions are implemented, for both Interval{Float64} and Interval{BigFloat}.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"The functions for Interval{Float64} internally use routines from the correctly-rounded CRlibm library where possible, i.e. for the following functions defined in that library:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"exp, expm1\nlog, log1p, log2, log10\nsin, cos, tan\nasin, acos, atan\nsinh, cosh","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Other functions that are implemented for Interval{Float64} internally convert to an Interval{BigFloat}, and then use routines from the MPFR library (BigFloat in Julia):","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"^\nexp2, exp10\natan, atanh","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Note, in particular, that in order to obtain correct rounding for the power function (^), intervals are converted to and from BigFloat; this implies a significant slow-down in this case.","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"Examples:","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> a = @interval(1)\n[1, 1]\n\njulia> sin(a)\n[0.84147, 0.841471]\n\njulia> cos(cosh(a))\n[0.0277121, 0.0277122]","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> setprecision(Interval, 53)\n53\n\njulia> sin(@interval(1))\n[0.84147, 0.841471]₅₃\n\njulia> @interval sin(0.1) + cos(0.2)\n[1.07989, 1.0799]₅₃","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> setprecision(Interval, 128)\n128\n\njulia> @interval sin(1)\n[0.84147, 0.841471]₁₂₈","category":"page"},{"location":"usage/#Interval-rounding-modes","page":"Basic usage","title":"Interval rounding modes","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"By default, the directed rounding used corresponds to using the RoundDown and RoundUp rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> setrounding(Interval, :slow)\n:slow","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"An alternative rounding method is to perform calculations using the (standard) RoundNearest rounding mode, and then widen the result by one machine epsilon in each direction using prevfloat and nextfloat. This is achived by","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> setrounding(Interval, :accurate);\n","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"It generally results in wider intervals, but seems to be significantly faster.","category":"page"},{"location":"usage/#Display-modes","page":"Basic usage","title":"Display modes","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"There are several useful output representations for intervals, some of which we have already touched on. The display is controlled globally by the setformat function, which has the following options, specified by keyword arguments (type ?setformat to get help at the REPL):","category":"page"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"format: interval output format\n:standard: output of the form [1.09999, 1.30001], rounded to the current number of significant figures\n:full: output of the form Interval(1.0999999999999999, 1.3), as in the showfull function\n:midpoint: output in the midpoint-radius form, e.g. 1.2 ± 0.100001\nsigfigs: number of significant figures to show in standard mode\ndecorations (boolean): whether to show decorations or not","category":"page"},{"location":"usage/#Examples","page":"Basic usage","title":"Examples","text":"","category":"section"},{"location":"usage/","page":"Basic usage","title":"Basic usage","text":"julia> setprecision(Interval, Float64)\nFloat64\n\njulia> a = @interval(1.1, pi)\n[1.09999, 3.1416]\n\njulia> setformat(sigfigs=10)\nDisplay parameters:\n- format: standard\n- decorations: false\n- significant figures: 10\n\njulia> a\n[1.099999999, 3.141592654]\n\njulia> setformat(:full)\nDisplay parameters:\n- format: full\n- decorations: false\n- significant figures: 10\n\njulia> a\nInterval(1.0999999999999999, 3.1415926535897936)\n\njulia> setformat(:midpoint)\nDisplay parameters:\n- format: midpoint\n- decorations: false\n- significant figures: 10\n\njulia> a\n2.120796327 ± 1.020796327\n\njulia> setformat(:midpoint, sigfigs=4)\nDisplay parameters:\n- format: midpoint\n- decorations: false\n- significant figures: 4\n\njulia> a\n2.121 ± 1.021\n\njulia> setformat(:standard)\nDisplay parameters:\n- format: standard\n- decorations: false\n- significant figures: 4\n\njulia> a\n[1.099, 3.142]\n\njulia> setformat(:standard, sigfigs=6)  # default values\nDisplay parameters:\n- format: standard\n- decorations: false\n- significant figures: 6","category":"page"},{"location":"multidim/#Multi-dimensional-boxes","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"","category":"section"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"Multi-dimensional (hyper-)boxes are implemented in the IntervalBox type. These represent Cartesian products of intervals, i.e. rectangles (in 2D), cuboids (in 3D), etc.","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"IntervalBoxes are constructed from an array of Intervals; it is often convenient to use the .. notation:","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"julia> using IntervalArithmetic # hide\n\njulia> X = IntervalBox(1..3, 2..4)\n[1, 3] × [2, 4]\n\njulia> Y = IntervalBox(2.1..2.9, 3.1..4.9)\n[2.09999, 2.90001] × [3.09999, 4.90001]","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"Several operations are defined on IntervalBoxes, for example:","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"julia> X ∩ Y\n[2.09999, 2.90001] × [3.09999, 4]\n\njulia> X ⊆ Y\nfalse","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"Given a multi-dimensional function taking several inputs, and interval box can be constructed as follows:","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"julia> f(x, y) = (x + y, x - y)\nf (generic function with 1 method)\n\njulia> X = IntervalBox(1..1, 2..2)\n[1, 1] × [2, 2]\n\njulia> f(X...)  \n([3, 3], [-1, -1])\n\njulia> IntervalBox(f(X...))\n[3, 3] × [-1, -1]","category":"page"},{"location":"multidim/","page":"Multi-dimensional boxes","title":"Multi-dimensional boxes","text":"DocTestSetup = nothing","category":"page"},{"location":"construction/#Constructing-intervals","page":"Constructing intervals","title":"Constructing intervals","text":"","category":"section"},{"location":"construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Constructing an interval is the most basic operation in the library. There are several methods to construct intervals listed below.","category":"page"},{"location":"construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Note that a valid interval [a, b] must have a ≤ b.","category":"page"},{"location":"construction/","page":"Constructing intervals","title":"Constructing intervals","text":"interval(x)\ninterval(x, y)\nThis is the most fundamental way to build an interval for a user. It accepts one or two floating-point values and constructs the resulting interval with lower and upper endpoints exactly equal to those floating-point values, checking that the resulting interval is valid:  \n\njulia> using IntervalArithmetic\n\njulia> @format full  # print out literal interval values in full\nDisplay parameters:\n- format: full\n- decorations: false\n- significant figures: 6\n\njulia> interval(0.1)\nInterval(0.1, 0.1)\n\njulia> interval(0.1, 0.2)\nInterval(0.1, 0.2)\n\njulia> interval(3.1f0)\nInterval(3.1, 3.1)\n\njulia> typeof(ans)\nIntervalArithmetic.Interval{Float32}\n\njulia> interval(Inf)\nERROR: ArgumentError: `[Inf, Inf]` is not a valid interval. Need `a ≤ b` to construct `interval(a, b)`.\n\njulia> interval(3, 2)\nERROR: ArgumentError: `[3, 2]` is not a valid interval. Need `a ≤ b` to construct `interval(a, b)`.\nNote that interval does not perform any rounding of the end-points. E.g.\njulia> x = interval(0.1)\nInterval(0.1, 0.1)\n\njulia> big(x)\nInterval(1.000000000000000055511151231257827021181583404541015625000000000000000000000000e-01, 1.000000000000000055511151231257827021181583404541015625000000000000000000000000e-01)\n\njulia> big\"0.1\" ∈ x\nfalse\nSee here for more on the need for rounding.","category":"page"},{"location":"construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x..y\nThis is a convenient syntax, and tries to be \"clever\" by interpreting the values as user-friendly numbers, rather than strict floating-point, and performing directed rounding automatically to give an interval that is guaranteed to contain the corresponding true real numbers. For example:\njulia> 0.1..0.2\nInterval(0.09999999999999999, 0.2)\n\njulia> big(ans)\nInterval(9.999999999999999167332731531132594682276248931884765625000000000000000000000000e-02, 2.000000000000000111022302462515654042363166809082031250000000000000000000000000e-01)\nSo 0.1..0.2 contains both the true real number 1/10 and 2/10.\nTo do so, floating-point values like 0.1 are treated as the smallest interval containing the true real number 1/10, given by the unexported atomic function:\njulia> IntervalArithmetic.atomic(Interval{Float64}, 0.1)\nInterval(0.09999999999999999, 0.1)\n\njulia> 0.1..0.1\nInterval(0.09999999999999999, 0.1)\nm ± r\nThe ± operator (typed as \\pm<TAB>) creates the interval with midpoint m and radius r, and is equivalent to (m - r) .. (m + r):\njulia> 1 ± 0.1\nInterval(0.8999999999999999, 1.1)\n@interval expr\nThe @interval macro takes a Julia expression and calculates an interval that is guaranteed to contain the true result of the calculation, treating literals in the same way as the .. operator, e.g.\njulia> x = @interval sin(0.1) + cos(0.2)\nInterval(1.0798999944880696, 1.07989999448807)\n\njulia> sin(big\"0.1\") + cos(big\"0.2\") ∈ x\ntrue","category":"page"},{"location":"construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Interval(x)\nInterval(x1, x2)\nInterval is the underlying interval constructor. Since v0.12 of the package, however, for efficiency reasons this performs no tests on the validity of the interval, and allows invalid intervals to be created. As a result, we recommend that this should not be used in user code; it should only be used in library functions which guarantee that the interval is already of the correct form.\nFor example, the following creates an invalid interval which will cause problems later:\njulia> Interval(3, 2)  # do *not* do this\n[3, 2]","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"DocTestSetup = quote\n    using IntervalArithmetic\nend","category":"page"},{"location":"decorations/#Decorations","page":"Decorations","title":"Decorations","text":"","category":"section"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"Decorations are flags, or labels, attached to intervals to indicate the status of a given interval as the result of evaluating a function on an initial interval. The combination of an interval X and a decoration d is called a decorated interval.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"The allowed decorations and their ordering are as follows: com > dac > def > trv > ill.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"Suppose that a decorated interval (X d) is the result of evaluating a function f, or the composition of a sequence of functions, on an initial decorated interval (X_0 d_0). The meaning of the resulting decoration d is as follows:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"com (\"common\"): X is a closed, bounded, nonempty subset of the domain of f; f is continuous on the interval X; and the resulting interval f(X) is bounded.\ndac (\"defined & continuous\"): X is a nonempty subset of mathrmDom(f), and f is continuous on X.\ndef (\"defined\"): X is a nonempty subset of mathrmDom(f), i.e. f is defined at each point of X.\ntrv (\"trivial\"): always true; gives no information\nill (\"ill-formed\"): Not an Interval (an error occurred), e.g. mathrmDom(f) = emptyset.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"An example will be given at the end of this section.","category":"page"},{"location":"decorations/#Initialisation","page":"Decorations","title":"Initialisation","text":"","category":"section"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"The simplest way to create a DecoratedInterval is with the @decorated macro, which does correct rounding:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> @decorated(0.1, 0.3)\n[0.1, 0.3]","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"The DecoratedInterval constructor may also be used if necessary:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> X = DecoratedInterval(3, 4)\n[3, 4]","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"By default, decorations are not displayed. The following turns on display of decorations:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> setformat(decorations=true)\nDisplay parameters:\n- format: standard\n- decorations: true\n- significant figures: 6\n\njulia> X\n[3, 4]_com","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"If no decoration is explicitly specified when a DecoratedInterval is created, then it is initialised with a decoration according to its interval X:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"com: if X is nonempty and bounded;\ndac if X is unbounded;\ntrv if X is empty.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"An explicit decoration may be provided for advanced use:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> DecoratedInterval(3, 4, dac)\n[3, 4]_dac\n\njulia> DecoratedInterval(X, def)\n[3, 4]_def","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"Here, a new DecoratedInterval was created by extracting the interval from another one and appending a different decoration.","category":"page"},{"location":"decorations/#Action-of-functions","page":"Decorations","title":"Action of functions","text":"","category":"section"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"A decoration is the combination of an interval together with the sequence of functions that it has passed through. Here are some examples:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> X1 = @decorated(0.5, 3)\n[0.5, 3]_com\n\njulia> sqrt(X1)\n[0.707106, 1.73206]_com","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"In this case, both input and output are \"common\" intervals, meaning that they are closed and bounded, and that the resulting function is continuous over the input interval, so that fixed-point theorems may be applied. Since sqrt(X1) ⊆ X1, we know that there must be a fixed point of the function inside the interval X1 (in this case, sqrt(1) == 1).","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> X2 = DecoratedInterval(3, ∞)\n[3, ∞]_dac\n\njulia> sqrt(X2)\n[1.73205, ∞]_dac","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"Since the intervals are unbounded here, the maximum decoration possible is dac.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> X3 = @decorated(-3, 4)\n[-3, 4]_com\n\njulia> sign(X3)\n[-1, 1]_def","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"The sign function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration is def.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> X4 = @decorated(-3.5, 4.1)\n[-3.5, 4.1]_com\n\njulia> sqrt(X4)\n[0, 2.02485]_trv","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"The negative part of X is discarded by the sqrt function, since its domain is [0,∞]. (This process of discarding parts of the input interval that are not in the domain is called \"loose evaluation\".) The fact that this occurred is, however, recorded by the resulting decoration, trv, indicating a loss of information: \"nothing is known\" about the relationship between the output interval and the input.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"In this case, we know why the decoration was reduced to trv. But if this were just a single step in a longer calculation, a resulting trv decoration shows only that something like this happened at some step. For example:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> X5 = @decorated(-3, 3)\n[-3, 3]_com\n\njulia> asin(sqrt(X5))\n[0, 1.5708]_trv\n\njulia> X6 = @decorated(0, 3)\n[0, 3]_com\n\njulia> asin(sqrt(X6))\n[0, 1.5708]_trv","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"In both cases, asin(sqrt(X)) gives a result with a trv decoration, but we do not know at which step this happened, unless we break down the function into its constituent parts:","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"julia> sqrt(X5)\n[0, 1.73206]_trv\n\njulia> sqrt(X6)\n[0, 1.73206]_com","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"This shows that loose evaluation occurred in different parts of the expression in the two different cases.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"In general, the trv decoration is thus used only to signal that \"something unexpected\" happened during the calculation. Often this is later used to split up the original interval into pieces and reevaluate the function on each piece to refine the information that is obtained about the function.","category":"page"},{"location":"decorations/","page":"Decorations","title":"Decorations","text":"DocTestSetup = nothing","category":"page"},{"location":"#IntervalArithmetic.jl","page":"Package","title":"IntervalArithmetic.jl","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"IntervalArithmetic.jl is a Julia package for performing Validated Numerics in Julia, i.e. rigorous computations with finite-precision floating-point arithmetic.","category":"page"},{"location":"","page":"Package","title":"Package","text":"All calculations are carried out using interval arithmetic: all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is guaranteed to contain the correct result, starting from the given initial data.","category":"page"},{"location":"","page":"Package","title":"Package","text":"The aim of the package is correctness over speed, although performance considerations are also taken into account.","category":"page"},{"location":"#Authors","page":"Package","title":"Authors","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"Luis Benet, Instituto de Ciencias Físicas, Universidad Nacional Autónoma de México (UNAM)\nDavid P. Sanders, Departamento de Física, Facultad de Ciencias, Universidad Nacional Autónoma de México (UNAM)","category":"page"},{"location":"#Contributors","page":"Package","title":"Contributors","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"Oliver Heimlich\nNikolay Kryukov\nJohn Verzani","category":"page"},{"location":"#Installation","page":"Package","title":"Installation","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"To install the package, from within Julia do","category":"page"},{"location":"","page":"Package","title":"Package","text":"julia> Pkg.add(\"IntervalArithmetic\")","category":"page"},{"location":"#Contents","page":"Package","title":"Contents","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"Pages = [\"usage.md\",\n    \"intro.md\",\n    \"decorations.md\",\n    \"multidim.md\",\n    \"rounding.md\",\n    \"api.md\",\n    \"input_output.md\"\n    ]","category":"page"},{"location":"#Bibliography","page":"Package","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"Validated Numerics: A Short Introduction to Rigorous Computations, W. Tucker, Princeton University Press (2010)\nIntroduction to Interval Analysis, R.E. Moore, R.B. Kearfott & M.J. Cloud, SIAM (2009)","category":"page"},{"location":"#Related-packages","page":"Package","title":"Related packages","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"MPFI.jl, a Julia wrapper around the MPFI C library, a multiple-precision interval arithmetic library based on MPFR\nIntervals.jl, an alternative implementation of basic interval functions.\nUnums.jl, an implementation of interval arithmetic with variable precision (\"ubounds\")","category":"page"},{"location":"#Acknowledgements","page":"Package","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Package","title":"Package","text":"This project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.","category":"page"},{"location":"","page":"Package","title":"Package","text":"Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a Cátedra Marcos Moshinsky (2013). DPS acknowledges a sabbatical fellowship from CONACYT and thanks Alan Edelman and the Julia group at MIT for hosting his sabbatical visit.","category":"page"},{"location":"input_output/#Input","page":"Input&Output","title":"Input","text":"","category":"section"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"IntervalArtihmetic allows to construct intervals using a string as input. The function parse converts the input string into an interval.","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"parse(::Interval{Type}, ::String)\nThe various string formats are as follows:\nNo string parameter or Empty string (\"[Empty]\") returns an empty interval.\nentire (\"[entire]\") and \"[,]\" string returns entireinterval\n\"[nai]\" returns Nai{Type}\n\"[m]\" returns Interval(m,m)\n\"[l, r]\" returns Interval(l, r)\n\"m?r\" returns Interval(m-r, m+r)\n\"m?ren\" returns Interval((m-r)en, (m+r)en)\n\"m?ru\" or \"m?rd\" returns Interval(m, m+r) or Interval(m-r, m) respectively\n\"m?\" returns Interval(m + 5 precision units, m - 5 precision units)\n\"m??\" returns Interval(-Inf, +Inf)\n\"m??u\" or \"m??d\" returns Interval(m, +Inf) or Interval(-Inf, m) respectively\nSimilarly, for decorated interval add _dec at the end of the string otherwise decoration is determined using decoration function.\n\njulia> parse(Interval{Float64}, \"[1, 2]\")\n[1, 2]\n\njulia> parse(Interval{Float64}, \"3.56?1\")\n[3.54999, 3.57001]\n\njulia> parse(Interval{Float64}, \"-10?\")\n[-10.5, -9.5]\n\njulia> parse(DecoratedInterval{Float64}, \"[3, 4]\")\n[3, 4]\n\njulia> parse(DecoratedInterval{Float64}, \"[3, 4]_dac\")\n[3, 4]\n\njulia> decoration(parse(DecoratedInterval{Float64}, \"[3, 4]_dac\"))\ndac::DECORATION = 3\n","category":"page"},{"location":"input_output/#Output","page":"Input&Output","title":"Output","text":"","category":"section"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"IntervalArtihmetic converts an interval and returns string which contains the input interval. The function intervaltotext takes a string conversion specifier cs as parameter and converts the interval to string accordingly.","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"-intervaltotext(::Interval)","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"Without conversion specifier, the intervaltotext function returns the input interval as string with maximum 5 digits of precision.","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"-intervaltotext(::Interval, ::string)","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"The format for default(infsup) string output is   \"overall_width : [ flags width . precision conversion]\"","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"overall_width, if specified denotes the length of the string. It must be followed by colon sign.\nThe following flags specify different format to output the string. 'C'   Returns upper case for Empty, Entire and Nai 'c'   Returns lower case for Empty, Entire and Nai '<'   Returns Entire as [-Inf, +Inf] instead of [Entire] '0'   Left-pads the numbers with zeros instead of spaces within the field width\nThe width specifies the length of lower and upper bound.\nThe precision for upper and lower bound denotes the number of digits after decimal.\nconversion determines the format of output interval string. 'e' of 'E' as conversion returns the interval in scientific notation. No conversion or any other letter returns default floating point representation.","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"The format of cs for uncertain string output is   \"overall_width : flags width . precision ? radius_width conversion\"","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"overall_width, if specified denotes the length of the string. It must be followed by colon sign.\nThe following flags specify different format to output the string. 'd'   Returns the interval with midpoint as upper bound and radius taken in downward direction. 'u'   Returns the interval with midpoint as lower bound and radius taken in upward direction. 'C'   Returns upper case for Empty, Entire and Nai 'c'   Returns lower case for Empty, Entire and Nai '+'   Returns positive numbers with '+' sign before the number '0'   Left-pads the numbers with zeros instead of spaces within the field width\nThe field width specifies the length of midpoint string.\nThe precision denotes the number of digits after decimal in the midpoint.\nThe radius_width specify the width of the radius. The radius is padded with zeroes.\nconversion determines the format of output interval string. 'e' or 'E' as conversion returns the interval in scientific notation. No conversion or any other letter returns default floating point representation.","category":"page"},{"location":"input_output/","page":"Input&Output","title":"Input&Output","text":"\njulia> interval_to_string(Interval(1, 4))\n\"[1, 4]\"\n\njulia> interval_to_string(Interval(1.123423423, 4.1334224))\n\"[1.12342, 4.13343]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \"8 : [c  .  ]\")\n\"[2.3, 4]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \" : [ 3 .  ]\")\n\"[2.3, 3.6]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \" : [ . 3 ]\")\n\"[2.353, 3.565]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \" : [ 4 . 2 ]\")\n\"[2.35, 3.57]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \"14 : [ . 3 ]\")\n\"[2.353, 3.565]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \"12 : [ 3 . 1]\")\n\"  [2.3, 3.6]\"\n\njulia> interval_to_string(Interval(23.534534644, 100.64537887687), \"12 : [ .  e]\")\n\"[2.3e1, 2e2]\"\n\njulia> interval_to_string(Interval(23.534534644, 100.64537887687), \"14 : [ .  e]\")\n\"[2.3e1, 1.1e2]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \" : [ 5 .  e]\")\n\"[2.3e0, 3.6e0]\"\n\njulia> interval_to_string(Interval(2.3534534644, 30.564537887687), \" : [ . 2 e]\")\n\"[2.35e0, 3.06e1]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \" : [ 6 . 1 e]\")\n\"[ 2.3e0,  3.6e0]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \"18 : [ . 3 e]\")\n\"[2.353e0, 3.565e0]\"\n\njulia> interval_to_string(Interval(2.3534534644, 3.564537887687), \"16 : [ 5 . 1 e]\")\n\"  [2.3e0, 3.6e0]\"\n\njulia> interval_to_string(3.55 .. 3.578, \"6 :  4 . 2 ?\")\n\"3.56?2\"\n\njulia> interval_to_string(3.55 .. 3.578, \"8 :u 4 . 2 ?\")\n\" 3.55?3u\"\n\njulia> interval_to_string(3.55 .. 3.578, \"8 :d 4 . 2 ?\")\n\" 3.58?3d\"\n\njulia> interval_to_string(Interval(3.555, 3.565), \"7 : . 3 ?\")\n\"3.560?5\"\n\njulia> interval_to_string(Interval(3.555, 3.565), \"8 :0 6 . 3 ?\")\n\"03.560?5\"\n\njulia> interval_to_string(35.5 .. 36.78, \"8 :  4 . 2 ? 1 e\")\n\"3.61?7e1\"\n\njulia> interval_to_string(35.55 .. 35.65, \"9 : . 3 ? 1 e\")\n\"3.560?6e1\"\n\njulia> interval_to_string(3.55 .. 3.578, \"6 :  4 .  ?\")\n\"3.56?2\"\n\njulia> interval_to_string(3.55 .. 3.578, \" :u 4 .  ?\")\n\"3.55?3u\"\n\njulia> interval_to_string(Interval(3.555, 3.565), \"7 : .  ?\")\n\"3.560?6\"\n\njulia> interval_to_string(35.5 .. 35.78, \"8 :  4 .  ? e\")\n\"3.56?2e1\"\n\njulia> interval_to_string(Interval(35.55, 35.65), \"9 : .  ? e\")\n\"3.560?6e1\"  \n","category":"page"}]
}
